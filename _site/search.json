[{"title":"Git &GitHub 기초","url":"/git/2024/05/06/Git-GitHub-Basic/","content":"### ▶ Git이란 무엇인가?\n<!--more-->\n\n> **Git**은 소프트웨어 개발 시에 사용되는 버전 관리 시스템의 일종이다.\n\n###  ▶ Git을 왜 사용하는 걸까?\n\n보편적으로 .hwp와 같은 문서 작업시 하나의 문서를 마구잡이로\n복사 -> 수정/백업을 할 때가 있다. \n![](https://velog.velcdn.com/images/ukja2/post/609c7f86-e073-44c8-88ae-292626ecf42e/image.png) \n이와 같은 경우의 문제점이 무엇이 있을까?\n> \n- 각각의 파일간 변경사항을 추적하기 어렵다.\n- 협업에 있어 상당한 번거로움이 있다.\n- 데이터 손상에 대한 복구가 어렵다.\n\n\n이러한 이유로 **체계적인 관리**의 중요성이 더욱 강조되고 있다.\n\n\n### ▶ Git의 핵심 기능\n**1. 소스 코드 변경사항 추적 및 관리**\n- 소스 코드가 변경되었을 때 이를 감지하고, 어떤 점이 변경되었는 지 확인할 수 있도록 한다.\n\n**2. 개발자 간 동시 작업 지원**\n- 개발자는 각기 다른 작업을 병렬적으로 수행할 수 있다.\n\n**3. 변경 사항 기록**\n- 프로젝트의 이전 버전으로 되돌아갈 수 있는 기능 제공한다.\n\n---\n![](https://velog.velcdn.com/images/ukja2/post/de06215a-dc16-4786-8397-241b0ae0bcfd/image.png)\n### ▶ GitHub란 무엇인가?\n> **Git**을 통해 관리되는 소프트웨어 프로젝트를 공유 및 협업하기 위해 사용되는 플랫폼이다.\n\n### ▶ GitHub의 핵심기능\n**1. 저장 및 버전 관리, 백업**\n- Git을 통해 관리하는 프로젝트를 GitHub에 저장, 버전 관리, 백업을 수행할 수 있다.\n\n**2. 협업기능 제공**\n- Pull-Request / Discussion 등과 같이 프로젝트를 함께 진행하는 팀원 간 협업을 위한 기능을 제공한다.\n\n**3. 문서화 기능 제공**\n- README / Wiki 등을 통해 프로젝트 문서화를 지원한다.\n\n**4. 소셜 네트워킹 기능 제공**\n- 본인 또는 다른 개발자의 작업물을 조회할 수 있다.\n---\n**💬 그렇다면 Git과 gitHub의 차이점은 무엇인가? **\n![](https://velog.velcdn.com/images/ukja2/post/9c83eee8-d736-4593-9a5c-959ebaa3f1a6/image.png)\n \nGit과 GitHub를 처음 다루면서 흔히 헷갈리는 개념이 'Git = GitHub’라고 혼동하는 것이다.\n\n>GitHub는 Git이라는 버전 관리 시스템으로 관리하는 프로젝트를 웹에서 볼 수 있도록(+다양한 편의 기능 제공) 해주는 서비스라는 점을 유의해야 한다.\n\n---\n![](https://velog.velcdn.com/images/ukja2/post/028a37f9-1188-4bd9-8691-6d9bd09fe83f/image.png)\n\n### ▶ Git Lifecycle\n**1. Untracked**\n- Git에서 관리하지 않는 파일들을 의미한다.\n\n**2. Tracked**\n- Git에서 관리하는 파일들을 의미한다.\n\n**3. Unmodified**\n- Git에서 관리하는 **파일 중 수정을 하지 않은 파일**들의 상태\n\n**4. Modified**\n- Git에서 관리하는 **파일 중 수정을 한 파일**들의 상태\n\n**5. Staged**\n- Git에서 관리하는 파일 중 **다음 커밋에 포함될 에정인 파일들**의 상태\n\n---\n### ▶ Git Command\n**1. status**\n```\ngit status \n```\n- Git을 통해 관리하고 있는 저장소의 상태를 출력한다.\n\n**2. init**\n```\ngit init\n```\n- init은 빈 Git repository를 만들거나 이미 있는 Repository를 다시 초기화하는 명령어다.\n\n**3. add**\n![](https://velog.velcdn.com/images/ukja2/post/ea85234f-a38f-4135-9a39-661b8df21fc9/image.png)\n```\ngit add \n```\n- #### `Untracked` -> `Staged`\n◽ 다음 commit에 포함시킨다. \n◽ Git에서 관리하지 않고 있던 파일을 관리하도록 하게 한다. \n\n- #### `Modified` -> `Staged`\n◽다음 commit에 포함시킨다.\n\n**4. commit **\n![](https://velog.velcdn.com/images/ukja2/post/9b8737cf-bf24-43cb-af54-b0b42d0b7e04/image.png)\n\n```\ngit commit -m \"수정 내용\"\n```\n- Git을 통해 관리하고 있는 **파일들의 상태를 저장**하는 명령어\n◽ `git add` 명령어를 통해 `Staged`된 파일들을 commit에 포함\n◽ `Unmodified` 상태로 만듦\n\n**5. push**\n![](https://velog.velcdn.com/images/ukja2/post/72548710-de3f-4ee8-b698-255bde00fa47/image.png)\n\n```\ngit push\n```\n\n- Git을 통해 관리하고 있는 `Local Repository`를 `Remote Repository`에 올리는(저장) 명령어\n◽ commit 목록을 GitHub Repository에 올림\n\n⭐ `local Repository` \n- .git 디렉터리가 있는 폴더이다.\n\n⭐ `Remote Repository`\n- 원격 서버에 있는 Git 저장소이다.\n---\n\n[출처] 개발자 이진우님의 블로그 : https://jinlee.kr/\n\n","excerpt":"<h3 id=\"-git이란-무엇인가\">▶ Git이란 무엇인가?</h3>\n\n"},{"title":"Jekyll wdm 문제 해결","url":"/jekyll/2024/09/08/Jekyll-wdm-error/","content":"### Ruby와 Jekyll을 사용한 블로그 제작 중 한가지 문제를 발견했다.\r\n\r\n<!--more-->\r\n\r\n실행 과정은 아래와 같다.\r\n\r\n1. Ruby 설치 후 jekyll과 bundler를 최신 버전으로 설치\r\n2. 내 컴퓨터 로컬저장소 내부에 `{사용자 이름}.github.io` 의 repo를 clone했다.\r\n3. clone한 repo 내부에 `jekyll new ./` 명령어로 프로젝트 생성\r\n4. bundle install 실행 / 여기서 문제가 발생했다.\r\n\r\n>An error occurred while installing wdm (0.1.1), and Bundler cannot continue.\r\n\r\n\r\n이는 wdm이 Windows 디렉토리 변경 감시 기능을 지원하지 않을 때 발생한다고 한다.\r\n\r\n나는 해당 문제를 해결하기 위해 다음과 같은 과정을 거쳤다.\r\n\r\n----\r\n\r\n### 1. WDM 수동 설치\r\n```\r\ngem install wdm \r\n```\r\n이후 다시 `bundle install`\r\n-> 결과는 똑같았다.\r\n\r\n### 2. Ruby 및 Bundler 업데이트\r\n-> 최신버전으로 설치했기에 문제가 없었다.\r\n\r\n이 외에도 로컬저장소 내부의 repo를 삭제후 다시 설치하는 등 여러가지 방법을 시도했지만 결과는 똑같았다.\r\n\r\n그렇게 여러 시행착오를 겪다 해결방안을 찾게 되었다.\r\n\r\n---\r\n\r\n### ✔ 해결방안 \r\n> `wdm` 은 `window` 내부에서만 필요한 gem 이라고 한다!\r\n\r\nWDM은 위에 설명했다시피 디렉토리 변경 감시기능을 제공하는데 이는 필수적이지 않기때문에 없이도 작동한다고 한다.\r\n\r\n![](https://velog.velcdn.com/images/ukja2/post/1c60cb11-9903-4511-b8d2-167f80debfaa/image.png)\r\n\r\ngemfile 내부에 들어가서\r\n> gem \"wdm\", \"~> 0.1.1\", :platforms => [:mingw, :x64_mingw, :mswin]\r\n\r\n해당 코드를 제거하고 `bundle install` 실행 하니 문제없이 정상 작동하게 됐다.","excerpt":"<h3 id=\"ruby와-jekyll을-사용한-블로그-제작-중-한가지-문제를-발견했다\">Ruby와 Jekyll을 사용한 블로그 제작 중 한가지 문제를 발견했다.</h3>\n\n"},{"title":"Jekyll theme를 이용한 블로그 개설과 오류 해결과정","url":"/jekyll/2024/09/09/Jektll-theme-blog/","content":"블로그를 개설 중 발생한 자잘한 오류 해결과 과정\n<!--more-->\n\n---\n### 1. Github.io repository 생성\n1. 우선 Github에서 ` {사용자이름}.github.io` 형식의 repo를 생성했다.\n![](https://velog.velcdn.com/images/ukja2/post/5ef7660a-842c-45e8-944c-b82ddfa30020/image.png)\n\n2. 저렇게 생성된 repo를 나의 로컬저장소에 clone한다.\n** 이때 clone할 repo의 경로에 한국어가 있으면 추후 오류가 발생할 확률이 있기 때문에 영어로 된 경로에 clone할 것을 권장한다. **\n\n\t나는 C 저장소에 따로 `Ukja2Blog` 라는 폴더를 생성 후 해당 폴더 내부에 clone했다.\n![](https://velog.velcdn.com/images/ukja2/post/48e553e3-3fbe-4deb-bc02-da92954d3428/image.png)\n\n\n### 2. Ruby 및 Jekyll 설치\n\n1. Ruby를 설치해준다.\n![](https://velog.velcdn.com/images/ukja2/post/626a70de-82d4-4e92-8121-3415f92a3108/image.png)\n여기서 `DEVKIT`가 포함된 버전으로 설치해주고, 설치버전은 오른 쪽 표시처럼  3.3.X 버전이 안정화된 버전임을 뜻하므로 여기에 해당되는 버전,bit를 설치해주면 된다.\n\n설치 후 `cmd` 창을 켜서 아래와 설치버전이 나오면 성공적으로 설치됐음을 의미한다.\n```\nruby -v (입력)\nruby 3.3.5 (2024-09-03 revision ef084cc8f4) [x64-mingw-ucrt] (출력)\n```\n2. Jekyll과 bundler 설치\n```\n$ gem install jekyll\n$ gem install bundler\n```\n\nJekyll과 bundler를 설치하는 이유를 쉽게 설명하자면 Ruby내에서 `bundler`를 통해 `Jekyll`을 실행하고 `Jekyll`을 사용해서 우리가 원하는 블로그를 만들 수 있다. \n\nbundler에 대한 설명은 아래와 같다.\n** \"bundler는 Ruby 프로젝트에 필요한 Gem들의 버전을 추적하고 설치해서 일관된 환경을 제공한다.\"**\n즉 다른 버전의 프로젝트들을 실행할때 원활하게 작동할 수 있도록 해주며, 전체적으로 Ruby의 쾌적한 사용환경을 제공해주는 것 같다.\n\n설치를 완료 했다면 아래와 같이 입력 후 설치 확인을 해준다.\n```\njekyll -v (입력)\njekyll 4.3.3 (출력)\n\nbundler -v (입력)\nBundler version 2.5.18 (출력)\n```\n\n### 3. Jekyll Theme 파일 넣기\n\n1. 원하는 Jekyll Theme를 아래 사이트에서 고른다.\n** http://jekyllthemes.org/ **\n\n2. 적용하고 싶은 테마의 파일을 압축해제 후 자신의 `github.io repository`를 clone한 폴더 내부로 옮겨준다.\n\n3. 테마를 폴더로 옮겨주었다면 `초기화 작업을 해주는 코드를 작성해야 되는데` 여기서 한 가지 문제가 발생한다.\n해당 코드인 `$ bash tools/init.sh`는 Linux 환경에서 사용할 수 있기 때문에 Windows   환경에서는 수동으로 초기화 하는 방법은 선택해야 된다. ** ( 처음부터 WSL을 활용해서 작업하는 것을 추천 ) **\n> https://devpro.kr/posts/Github-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-(3)/\nLinux 환경에서 작업할 수 없다면 위 링크를 통해 따라하도록 하자\n!! 이렇게 했을 시 환경에 따라 오류가 발생할 수도 있다. 이는 후술함 !!\n\n4. 초기화 작업을 해주었다면 `git bash` 로 `bundler install` 을 입력하면 정상적으로 테마적용이 완료될 것이다.\n\n이후 `config.yml` 과  `assets` 폴더 내부의 css 파일을 수정하는 등 자신의 취향에 맞게 블로그를 꾸밀 수 있다. \n\n모든 설정이 끝나면 아래 코드를 git bash에 입력하면\n```\n$ bundle exec jekyll serve\n```\n![](https://velog.velcdn.com/images/ukja2/post/c203c8b4-d424-4609-872c-8a7b8a79ef02/image.png)\n\n노란색으로 표시한 Server address의 호스팅 주소를 브라우저에 입력하면 자신만의 블로그가 나타난다.\n![](https://velog.velcdn.com/images/ukja2/post/6a8311f1-8fef-4a89-9cd2-54234a816c80/image.png)\n\n---\n## 오류발생과 해결\n\n### 1. Ruby와 jekyll을 처음 설치하고 테마를 적용하기 전 `jekyll new ./`을 통해 첫 프로젝트 생성후 `bundler install` 실행 시 발생한 오류 \n>An error occurred while installing wdm (0.1.1), and Bundler cannot continue.\n\n위 오류에 대한 해결방법은 나의 벨로그에 작성해 놓았다.\n\n### 2. bundle exec로 블로그 실행 시 git bash에 나타난 오류\n> assets/js/dist/*.min.js Not Found \n\n`~~.min.js` 를 찾을 수 없다는 뜻인데\nJekyll Theme는 JavaScript 기반이다 보니 다양한 기능을 적용시키기 위해서는 Node.js가 필요하다. ex) 다크모드, 라이트모드, 검색창기능\n\n이를 해결하기 위해 수많은 검색을 하다가 해결 방법을 찾아냈다.\n\n1. `tools/init.sh` 은 Linux 환경의 node.js를 통해서 사용할 수 있다. \n2. 위 작업을 해주면 `assets/js/dist/*.min.js` 자동으로 생성되는 구조이다. \n아마 내 생각엔 `tools/init.sh` 스크립트 내부에 build를 해주는 기능이 포함된 것 같다.\n3. 나는 `tools/init.sh` 대신 수동으로 초기화 작업을 했기 때문에  `*.min.js`가 생성될 수 없었다.\n\n그래서 나는 없는 `*.min.js` 파일을 Node.js를 통해 build하는 방법을 사용했다.\n\n1. 우선 Node.js를 설치\n2. git bash로 `npm install` , `npm run build`를 입력해주면 위의 오류가 사라지는 것을 확인할 수 있다. *npm install을 하는 과정에서 아래와 같은 오류가 발생했다. 이와 별개로 위 작업이 정상적으로 진행된다면 오류는 해결된다.*\n\n\n\n### 3. Node.js를 설치하고 `npm install`을 설치 과정 중 발생한 오류\n>  bash: npm: command not found\n\n위와 같은 오류가 발생했는데 이는 Node.js 설치폴더가 환경변수에 등록되어 있지 않기 때문에 발생한다. \n이는 https://wonisdaily.tistory.com/209 해당 블로그를 참고해서 해결했다.\n\n---\n내가 한 방식이 정답이 아닐 수 있으나 해결했으니 마음이 후련하다~","excerpt":"<p>블로그를 개설 중 발생한 자잘한 오류 해결과 과정</p>\n\n"},{"title":"(SpringBoot🍃) SpringBoot 프로젝트 생성","url":"/springboot/2025/01/19/spring/","content":"![](https://velog.velcdn.com/images/ukja2/post/f5a31409-56dc-4b07-bbbe-490beb314b9e/image.png)\r\n\r\n스프링부트 프로젝트 생성시 참고사항\r\n<!--more-->\r\n\r\n\r\n### Project Metadata\r\n- Group : 프로젝트가 속한 조직이나 회사 이름을 나타내며, Group값은 기본적으로 Java 프로젝트의 최상위 패키지 이름으로 사용됨\r\n- Artifact : 프로젝트의 이름\r\n- Packaging \r\n\t![](https://velog.velcdn.com/images/ukja2/post/1e1f9960-567f-49ae-8354-bfec19829826/image.png)\r\n언제 JAR과 WAR을 선택할까?\r\n‣ JAR:\r\nSpring Boot의 내장 서버를 활용해 간단히 실행 가능한 애플리케이션을 만들고 싶을 때.\r\n마이크로서비스 아키텍처를 사용할 때.\r\n‣ WAR:\r\n기존 서블릿 컨테이너(Tomcat, JBoss 등)에 배포해야 할 때.\r\n레거시 시스템과의 호환성이 필요할 때.\r\n\r\n- Java : JDK 버전에 맞게 선택\r\n\r\n### Dependencies\r\n스프링 프레임워크를 사용할 때 특정 기능을 구현하기 위해 다양한 라이브러리를 추가해야 되는데, 이를 직접 설정하는 대신 이니셜라이저가 제공하는 옵션에서 선택할 수 있다.\r\n\r\n예를 들어\r\n- `Spring Web` : 웹 애플리케이션 개발을 위한 종속성 (Spring MVC 포함).\r\n- `Spring Boot DevTools` : 개발 편의를 위한 도구 (자동 리로드 기능 등).\r\n- `Spring Data JPA` : 데이터베이스 연동을 쉽게 해주는 라이브러리.\r\n- `Spring Security` : 인증과 권한 관리를 위한 라이브러리.\r\n- `Thymeleaf` : HTML 템플릿 엔진.\r\n\r\n종속성의 역할\r\n\r\n- 기능 추가: 필요한 라이브러리를 자동으로 프로젝트에 포함시켜 줌.\r\n- 간편한 설정: 각 라이브러리에 맞는 기본 설정을 자동으로 제공.\r\n- 의존성 관리: 관련된 라이브러리 버전을 스프링 부트에 맞게 맞춰줌.\r\n","excerpt":"<p><img src=\"https://velog.velcdn.com/images/ukja2/post/f5a31409-56dc-4b07-bbbe-490beb314b9e/image.png\" alt=\"\" /></p>\n\n<p>스프링부트 프로젝트 생성시 참고사항</p>\n\n"},{"title":"「 Linux 」 리눅스?","url":"/linux/2025/02/20/Linux-outline/","content":"## Linux?\n<!--more-->\n\n- Unix 기반의 오픈소스 OS\n- 윈도우, MacOS와 달리 **무료**이며, **오픈소스**이기 때문에 자유롭게 수정과 배포가 가능함\n\n**운영체제(OS)**: **하드웨어**를 프로그램을 통해 쉽게 사용할 수 있도록 해주는 **소프트웨어**이다.\n\n여기서 설명하는 리눅스는 **완전한 리눅스**를 뜻함 이는 후술하겠음\n## 💻 Linux 기본구조\n크게 4가지로 나뉜다.\n\n### 1. 커널(Kernel)\n운영체제의 핵심으로 **하드웨어와 소프트웨어를 연결하는 역할**을 함.\n\n\n\n###  커널의 역할\n\n| 역할 | 설명 |\n|------|------|\n| **프로세스 관리** | 실행 중인 프로그램(프로세스)을 생성, 실행, 종료 및 스케줄링 |\n| **메모리 관리** | RAM 및 가상 메모리를 효율적으로 할당 및 해제 |\n| **파일 시스템 관리** | 파일과 디렉토리, 저장장치를 관리 |\n| **장치 관리** | CPU, 디스크, 네트워크 장치 등 하드웨어를 제어 |\n| **네트워크 관리** | 네트워크 인터페이스 및 데이터 통신을 담당 |\n\n\n\n###   정리\n✅ **커널은 OS의 핵심이며, 프로세스, 메모리, 파일, 장치, 네트워크 관리 담당**  \n✅ **운영체제의 성능과 안정성에 중요한 역할을 함**\n\n\n---\n### 2. 쉘(Shell)\n사용자가 운영체제(커널)와 소통할 수 있도록 **명령어를 입력받고 실행하는 인터페이스**.  \n쉽게 말해, **사용자의 명령을 해석해서 커널에 전달하는 번역기 역할**을 함.\n\n\n\n### 쉘의 역할\n\n| 역할 | 설명 |\n|------|------|\n| **명령어 해석** | 사용자가 입력한 명령어를 해석하여 커널에 전달 |\n| **프로그램 실행** | 사용자가 입력한 명령어 또는 스크립트를 실행 |\n| **파일 & 디렉토리 관리** | 파일 생성, 삭제, 이동 등의 작업 수행 |\n| **프로세스 제어** | 실행 중인 프로세스를 백그라운드/포그라운드 전환 및 종료 |\n| **스크립트 실행** | 반복적인 작업을 자동화할 수 있는 쉘 스크립트 지원 |\n\n\n\n### 쉘의 종류\n\n| 쉘 종류 | 특징 |\n|---------|------------------|\n| **Bash (Bourne Again Shell)** | 가장 많이 사용되는 기본 쉘 (리눅스 기본) |\n| **Sh (Bourne Shell)** | Bash의 원조, 가벼운 쉘 |\n| **Zsh (Z Shell)** | 강력한 자동 완성 & 플러그인 지원 |\n\n\n📌 **리눅스 기본 쉘은 Bash**이며, 필요에 따라 다른 쉘로 변경 가능.\n\n\n\n##  정리\n✅ **쉘은 사용자가 커널과 소통할 수 있도록 해주는 인터페이스**  \n✅ **명령어 실행, 파일 관리, 프로세스 제어, 스크립트 자동화 기능을 제공**  \n✅ **Bash가 기본이지만 Zsh, Fish 같은 다양한 쉘도 사용 가능**\n\n---\n\n### 3. 하드웨어(Hardware)\n\n**컴퓨터구조**에서 더욱 자세히 다룸 \n\n| 하드웨어       | 설명                                           |\n|----------------|------------------------------------------------|\n| **CPU (Central Processing Unit)** | 컴퓨터의 두뇌, 모든 계산과 명령을 처리함         |\n| **메모리 (RAM)**              | 데이터를 일시적으로 저장, 프로그램 실행에 필요한 데이터를 빠르게 읽고 씀 |\n| **저장 장치 (Hard Disk, SSD)** | 데이터를 영구적으로 저장하는 장치, 컴퓨터가 꺼져도 데이터가 유지됨 |\n| **입출력 장치 (Input/Output Devices)** | 사용자가 컴퓨터와 상호작용할 수 있게 돕는 장치, 예: 키보드, 마우스, 모니터 등 |\n\n---\n\n### 4. 프로그램(Program)\n\n**프로그램**은 **하드웨어에서 실행되는 소프트웨어**로, 특정 작업을 수행하거나 시스템을 제어하는 코드들로 구성\n\n| 프로그램 종류       | 설명                                             |\n|---------------------|--------------------------------------------------|\n| **시스템 소프트웨어**   | 하드웨어와 사용자 간 상호작용을 도와주는 소프트웨어, 예: 운영체제(OS) |\n| **응용 소프트웨어**     | 특정 작업을 수행하는 소프트웨어, 예: 웹 브라우저, 게임, 워드 프로세서 등 |\n\n---\n## 💻 GNU 프로젝트와 리눅스 관계\n리눅스라고 했을 때 우리가 보통 리눅스 OS라고 부르는 것은 사실 리눅스 커널과 그 위에 추가적인 소프트웨어들, 즉 툴들이 결합된 운영체제를 의미함\n\n즉,\n- **리눅스 커널**만으로는 운영체제가 아님 → **GNU 프로젝트의 툴**과 결합해서 완전한 OS가 됨.\n- 그래서 **GNU/Linux**라고도 부름.  \n  (예: Ubuntu는 GNU 툴 + 리눅스 커널을 포함한 배포판)\n---\n##  💻 리눅스 배포판 (Linux Distribution)\n위에서 설명했다시피 리눅스는 커널만으로 동작하지 않기 때문에 \n**리눅스 커널 + GNU 프로젝트(또는 툴)** 을 조합해서 만든 **배포판**을 통해 **완전한 리눅스**를 사용할 수 있다.\n\n\n### 대표적인 배포판  \n| 배포판  | 특징 |\n|---------|----------------|\n| **Ubuntu**  | 초보자 친화적, 데스크탑 & 서버용으로 인기 |\n| **CentOS**  | 안정성이 뛰어나 서버용으로 많이 사용됨 (RHEL 기반) |\n| **Debian**  | 보안과 안정성이 뛰어나며 다양한 파생판이 존재 |\n| **Fedora**  | 최신 기술 반영이 빠르며 Red Hat 지원 |\n| **Arch Linux**  | 최소한의 기본 구성, 사용자가 직접 커스터마이징 |\n--- \n\n## 💻 CLI vs GUI\n| 인터페이스 | 설명 |\n|------------|--------------------------------------------------|\n| **CLI (Command Line Interface)** | 명령어 기반, 터미널 사용 (서버 관리에 최적화) |\n| **GUI (Graphical User Interface)** | 그래픽 환경 제공 (데스크탑 사용에 적합) |\n- 리눅스는 기본적으로 CLI 중심이지만, GUI 환경도 사용 가능.  \n- **서버 운영 = CLI**, **일반 사용자 = GUI** 선택 가능\n\n\n","excerpt":"<h2 id=\"linux\">Linux?</h2>\n\n"},{"title":"「 Linux 」 리눅스 명령어","url":"/linux/2025/02/20/Linux-Command/","content":"##  Linux 기본 명령어\n\n<!--more-->\n\n### ⚙️ 1. 파일 및 디렉토리 관리\n###  `ls` : 디렉토리 내용 목록 보기\n현재 디렉토리 안에 있는 파일이나 폴더들을 보여줌\n\n`ls` : 현재 디렉토리의 파일과 폴더 목록을 나열\n`ls -l` : 파일의 세부 정보까지 나열\n`ls -a` : 숨겨진 파일까지 모두 나열\n`ls -lh` : 사람이 읽기 좋은 형식으로 파일 크기 표시\n\n### `cd` : 디렉토리 이동\n현재 작업 중인 디렉토리를 바꾸는 명령어\n\n`cd /home/user` : 지정된 경로로 이동\n`cd ..` : 상위 디렉토리로 이동\n`cd ~` : 홈 디렉토리로 이동\n`cd` : 아무 옵션 없이 입력하면 기본적으로 홈 디렉토리로 이동\n\n### `pwd` : 현재 작업 중인 디렉토리 경로 출력\npwd는 현재 내가 있는 디렉토리의 경로를 알려주는 명령어\n\n`pwd` : 현재 작업 중인 디렉토리 경로 출력 (예: /home/user)\n\n### `cp` : 파일 복사\ncp는 파일이나 디렉토리를 다른 위치로 복사하는 명령어\n\n`-r` : 디렉토리 복사 시 필요 (디렉토리 안의 파일과 하위 디렉토리까지 복사)\n`-i` : 덮어쓰기 전에 사용자에게 확인을 요구\n\n`cp file1.txt /backup/` : file1.txt를 /backup/ 디렉토리로 복사\n`cp -r /home/user /backup/`: /home/user 디렉토리와 그 안의 모든 파일을 /backup/로 복사\n\n###  `mv` : 파일/디렉토리 이동 또는 이름 변경\nmv는 파일이나 디렉토리를 이동하거나 이름을 변경하는 명령어\n\n`-i` : 덮어쓰기 전에 사용자에게 확인을 요구\n\n`mv file1.txt /backup/` : file1.txt를 /backup/ 디렉토리로 이동\n`mv oldname.txt newname.txt` : oldname.txt 파일의 이름을 newname.txt로 변경\n\n### `rm` : 파일 삭제\nrm은 파일을 삭제하는 명령어\n\n`-r` : 디렉토리와 그 안의 파일을 재귀적으로 삭제\n`-f` : 강제로 삭제 (파일이 없더라도 경고 없이 삭제)\n\n`rm file1.txt` : file1.txt 파일 삭제\n`rm -r directory/` : directory 디렉토리와 그 안의 모든 파일 삭제\n`rm -f file1.txt` : 경고 없이 강제로 file1.txt 삭제\n\n### `mkdir` : 디렉토리 생성\n새로운 디렉토리를 생성하는 명령어\n\n`-p` : 부모 디렉토리까지 함께 생성 ( 경로에 부모 디렉토리가 없으면 부모 디렉토리까지 한 번에 생성 )\n\n`mkdir my_folder` : my_folder라는 새 디렉토리 생성\n`mkdir -p projects/webapp/assets` : projects/webapp/assets 경로에 필요한 모든 디렉토리 생성\n\n### `touch` : 빈 파일 생성 또는 수정 시간 갱신\n새로운 파일을 생성하거나 기존 파일의 수정 시간을 갱신하는 명령어\n\n`touch myfile.txt` : myfile.txt라는 빈 파일을 생성하거나 기존 파일의 수정 시간을 갱신\n\n### `rmdir` : 빈 디렉토리 삭제\n비어 있는 디렉토리만 삭제할 수 있는 명령어\n\n`-p` : 부모 디렉토리까지 삭제\n빈 디렉토리를 삭제하면서, 그 부모 디렉토리가 비어 있으면 부모 디렉토리까지 삭제\n\n`rmdir my_folder` : my_folder라는 빈 디렉토리 삭제\n`rmdir -p projects/webapp/assets` : assets, webapp, projects가 모두 비어 있으면 한 번에 부모 디렉토리까지 삭제\n\n---\n\n## 🔍 2.파일 내용 조회\n\n### `cat` : 파일 내용 출력\n- 파일의 내용을 전체 출력\n- 내용이 길면 한 번에 다 나와서 화면을 넘기기 어려울 수 있음\n\n`cat myfile.txt` : myfile.txt 파일 내용을 화면에 한 번에 출력\n\n![alt text](<스크린샷 2025-02-17 14.44.08.png>)\n\n### `more` : 파일 내용 한 페이지씩 출력\n\n- 파일을 한 페이지씩, 화면을 넘겨서 볼 수 있는 명령어\n- 파일 내용이 길 때 유용\n  \n`more myfile.txt` : myfile.txt 파일을 한 페이지씩 출력하면서 볼 수 있음\n\n### `less` : 파일 내용 스크롤하며 출력\n- more와 비슷하지만 더 많은 기능 제공\n- less는 양 방향 스크롤이 가능 (위로, 아래로)\n\n`less myfile.txt` : myfile.txt 파일을 스크롤하며 내용 확인, q를 눌러 종료\n\n### `head` : 파일의 처음 10줄 출력\n- 파일의 앞부분 10줄만 출력\n- 출력할 줄 수는 `-n` 옵션으로 변경 가능\n`head myfile.txt` :  myfile.txt 파일의 처음 10줄을 출력\n`head -n 20 myfile.txt` : myfile.txt 파일의 처음 20줄을 출력\n\n### `tail` : 파일의 마지막 10줄 출력\n- 파일의 뒷부분 10줄만 출력\n- 출력할 줄 수는 `-n` 옵션으로 변경 가능\n- `-f` 옵션을 사용하면 파일 내용의 변화를 실시간으로 추적 가능\n`tail myfile.txt` : myfile.txt 파일의 마지막 10줄을 출력\n`tail -n 20 myfile.txt` : myfile.txt 파일의 마지막 20줄을 출력\n`tail -f myfile.txt` : 파일이 업데이트될 때마다 마지막 줄을 계속 출력 (로그 파일 등 실시간 모니터링 시 유용)\n\n### `grep` : 파일에서 특정 문자열 검색\n- 파일 내에서 특정 문자열을 검색하고 해당 부분을 출력\n- 대소문자 구분 없이 검색하려면 `-i` 옵션 사용\n  \n`grep \"hello\" myfile.txt` : myfile.txt 파일에서 hello라는 문자열을 찾고 출력\n`grep -i \"hello\" myfile.txt` : hello를 대소문자 구분 없이 검색\n`grep -r \"hello\"` : 현재 디렉토리와 하위 디렉토리에서 hello 검색\n\n---\n## 🔒 3. 파일 및 디렉토리 권한\n\n### `chmod` : 파일 권한 변경\n\n- chmod 명령어는 파일이나 디렉토리의 읽기/쓰기/실행 권한을 변경할 때 사용\n- 권한은 숫자나 기호로 설정할 수 있음\n\n`권한의 숫자 값`\n\n`r` (읽기): 4\n\n`w` (쓰기): 2\n\n`x` (실행): 1\n\n각 권한을 숫자값으로 합쳐서 설정\n\n예시 (숫자로 설정):\n- `chmod 755 myfile.txt` \n  - 소유자에게 읽기/쓰기/실행 권한, 그룹과 다른 사용자에게 읽기/실행 권한을 부여\n  - 7 = rwx, 5 = r-x, 5 = r-x\n\n예시 (기호로 설정):\n\n- `chmod u+x myfile.txt`\n    - 소유자(u)에게 실행 권한 추가\n\n- `chmod go-r myfile.txt`\n    - 그룹(g)과 다른 사용자(o)에서 읽기 권한 제거\n\n### `chown` : 파일 소유자와 그룹 변경\n- chown 명령어는 파일이나 디렉토리의 소유자와 그룹을 변경하는 명령어\n- 기본적으로 chown <소유자>:<그룹> <파일> 형태로 사용\n- 소유자와 그룹을 바꾸지 않으려면 생략 가능\n\n- `chown user:group myfile.txt`\n    - myfile.txt의 소유자를 user, 그룹을 group으로 변경\n- `chown user myfile.txt`\n    - myfile.txt의 소유자만 user로 변경\n- `chown :group myfile.txt`\n    - myfile.txt의 그룹만 group으로 변경\n\n---\n\n## 💻 이 외의 추가적인 명령어\n\n### `echo` : 텍스트나 변수 값을 출력할 때 사용\n\n`echo Hello, World!` : 화면에 \"Hello, World!\" 출력\n\n`echo $HOME` : 현재 사용자의 홈 디렉토리 경로 출력\n\n`echo \"My name is $USER\"` : 변수 사용 (현재 사용자 이름 출력)\n\n### `sudo` : 관리자 권한으로 명령어를 실행할 때 사용\n- sudo는 \"SuperUser Do\"의 줄임말로, 일반 사용자가 관리자 권한을 얻어 명령어를 실행할 수 있게 함. \n- 예를 들어 시스템 파일을 수정하거나, 패키지를 설치할 때 필요\n\n`sudo apt-get update` : 시스템 패키지 목록을 업데이트 (Ubuntu 기준)\n\n`sudo rm -rf /` : 주의! 시스템을 파괴할 수 있음 (루트 디렉토리 삭제)\n","excerpt":"<h2 id=\"linux-기본-명령어\">Linux 기본 명령어</h2>\n\n"},{"title":"「 Linux 」 Apache Web Server 구축 (1)","url":"/linux/2025/03/04/Apache-Web_Server/","content":"## 리눅스 웹 서버 구축\n오픈 소스 웹 서버 소프트웨어인 `Apache` 를 사용해서 웹 서버를 구축해보려 한다.\n<!--more-->\n\n### 🌍 웹 서버?\n- 웹 서버는 사용자가 웹 브라우저에서 요청한 웹 페이지를 제공하는 서버. 쉽게 말해서, 웹 사이트를 실행하는 컴퓨터라고 생각할 수 있음. \n\n- 웹 서버는 HTTP 프로토콜을 사용해서 클라이언트(브라우저)와 서버 간에 데이터를 주고받음\n\n---\n\n나는 MacOS 환경에서 진행하기에 이에 맞는 방법으로 시작할 것이다.\n\n### 1️⃣ Apache 설치\n> brew install httpd\n\n터미널에서 Homebrew를  통해 Apahce를 설치한다.\n\n### 2️⃣Apache 웹 서버 시작\n> sudo apachectl start\n\n터미널에서 위 명령어를 치면 Apache 서버를 시작할 수 있다.\n\n주소창에 `http://localhost` 을 입력해보자.\n\n- 서버 중지\n> sudo apachectl stop\n\n- 서버 재시작\n> sudo apachectl restart\n\n### ⚠️ 오류 발생 시 팁\n하지만 대부분의 경우 처음 Apache 서버를 시작할 때 `AH00558`라고 적힌 에러코드를 발견할 수 있을 것이다.\n\n이는 Apache 서버의 전역의 지시문으로 Servername에 대한 설정이 누락된 것으로, 해당 부분을 localhost로 변경해주면 된다.\n\n> sudo nano /etc/apache2/httpd.conf\n\n위 명령을 통해 텍스트파일 편집기로 `httpd.conf` 파일 내부에 `^w` 단축키로 **Servername** 을 입력하면 `#Servername ~~~` 와 같이 주석처리 되어있는 Servername을 확인할 수 있다. 여기서 `#`을 제거해주고 \nApache를 재시작해주면 정상적으로 **작동할 수도 있다.**\n\n#### 작동할 수도 있다??\n여기서 주석문을 수정했는데 적용이 안된다면 나와 같은 경우일 수도 있다. \n\n우선 나는 Apache를 Homebrew를 통해 설치할 때 경로가 다르게 설정된 것 같다. 위의 코드로 httpd.conf 파일에 이동하면 아무것도 없었기 때문이다. \n\n이럴 때는\n>which httpd\n\n명령어를 통해 Apache 파일이 정확히 어디에있는지 확인한 후 \n\n>sudo nano /opt/homebrew/etc/httpd/httpd.conf\n\n위 코드를 통해 다시 적용하고 서버를 재시작하면 작동될 것이다.\n\n### ⚠️ Port 설정\n\n만약 `http://localhost`를 입력했는데 안되고, `http://localhost:8080`이 된다면? \n\n-> Apache conf 파일로 이동해서 Listen을 검색하면 Port 번호가 8080으로 되어있을 것이다. 이를 `80 (기본포트)`로 변경해주면 된다.\n\n![](https://velog.velcdn.com/images/ghkdehs/post/46421195-4930-4d18-9962-4ce000873a55/image.png)\n\n\n\n### 3️⃣ 웹 페이지 구축\n\n* 나는 설치 경로가 다르므로 앞으로 나의 경로에 맞게 작성함\n\n아래 명령어를 통해 디렉토리로 이동하면 `index.html` 파일이 있을 것이다.\n\n\n> cd /opt/homebrew/var/www\n\n`index.html`파일은 내가 보여줄 기본 홈페이지 화면이다. 이를 vscode 를 통해 간단한 구문을 적어보도록 하겠다.\n\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>My Web Page</title>\n</head>\n<body>\n    <h1>Welcome to My Apache Web Server!</h1>\n    <p>This is my first webpage on Apache.</p>\n</body>\n</html>\n```\n이를 적용하면 바뀐 모습을 볼 수 있다.\n\n![](https://velog.velcdn.com/images/ghkdehs/post/45bb71ed-d9f0-41d7-bc0f-24ac536c4ae9/image.png)\n\n\n여기까지 기초적인 웹 서버 자체를 구축했다. \n다음부터 웹 서버 운영을 다뤄보려 한다.\n  \n  ","excerpt":"<h2 id=\"리눅스-웹-서버-구축\">리눅스 웹 서버 구축</h2>\n<p>오픈 소스 웹 서버 소프트웨어인 <code class=\"language-plaintext highlighter-rouge\">Apache</code> 를 사용해서 웹 서버를 구축해보려 한다.</p>\n\n"},{"title":"「 ComputerNetwork 」 네트워크 소개 및 OSI 7 계층","url":"/computernetwork/2025/03/11/ComputerNetwork/","content":"## 컴퓨터 네트워크 개요\n<!--more-->\n\n- 프로토콜이란 무엇인가?\n\n- 네트워크 엣지: 호스트, 액세스 네트워크, 물리적 매체\n\n- 네트워크 코어: 패킷/회선 교환, 인터넷 구조\n\n- 프로토콜 계층, 서비스 모델\n\n---\n\n## Introduction\n\n#### 1️⃣ Billions of connected computing `devices`\n수십억 개의 연결된 컴퓨터 장치들\n- `Hosts` = end system  \n호스트는 종단 시스템으로 사용자가 직접 사용하는 장치 (스마트폰, pc) 등을 의미한다.\n- running network apps at Internet’s \"edge\"\n인터넷의 \"끝부분(엣지)\"에서 네트워크 애플리케이션 실행\n(웹 브라우저, 이메일, 동영상 스트리밍 같은 네트워크 기반 프로그램 실행)\n\n#### 2️⃣ Packet switches\n데이터를 작은 조각(패킷)으로 나눠서 전달하는 장치\n- 인터넷에서 데이터를 한 번에 보내기 힘드니까, 작은 패킷으로 잘라서 보냄.\n- 각 패킷은 주소, 순서, 내용을 가지고 있고, 목적지에서 다시 조립됨\n\n- `routers`, `switches` : 패킷 스위치의 한 종류로 패킷을 목적지로 보내는 역할\n\n#### 3️⃣ Communication links\n통신 링크 (장치 간 데이터 전달 경로)\n\n- fiber, copper, radio, satellite \n  광섬유, 구리선, 무선(라디오), 위성\n- transmission rate: bandwidth\n전송 속도: 대역폭 (일정 시간 동안 전송 가능한 데이터 양)\n\n#### 4️⃣ Networks\n네트워크 (장치, 라우터, 링크의 집합체)\n\n- 장치, 라우터, 링크로 이루어진 집합: ISP(인터넷 서비스 제공자)\"나 \"네트워크 관리자\" 에 의해 관리됨 \n\n#### 5️⃣ Internet: \"network of networks\"\n인터넷은 네트워크들의 네트워크\n- 인터넷은 전 세계 수많은 작은 네트워크들이 연결된 거대한 네트워크\n(예: 집, 학교, 회사의 네트워크가 인터넷을 통해 서로 연결됨)\n\n#### 6️⃣ `Protocols` are everywhere\n- **프로토콜은 데이터를 주고받는 규칙**\n네트워크에서 정해진 규칙이 없으면 서로 이해할 수 없으니까 꼭 필요함\n\n- 프로토콜의 역할 : 메시지 전송과 수신을 제어\n\n**대표적인 프로토콜 예시**\n- HTTP: 웹 페이지를 주고받는 규칙 (인터넷 브라우징)\n- TCP/IP: 데이터가 안전하게 전송되도록 보장\n- Wi-Fi: 무선 네트워크 연결\n- 4G: 모바일 데이터 통신\n- Ethernet: 유선 네트워크 통신\n- CAN: 자동차에서 쓰는 통신 규약\n\n#### 7️⃣ Internet standards\n인터넷 표준 : 인터넷에서 사용하는 공식 규칙\n\n- RFC (Request for Comments)\n인터넷 표준을 정의하는 문서\n새로운 기술이나 프로토콜을 만들 때 RFC 문서로 공개하고 의견을 받음\n(예: HTTP, TCP/IP 같은 중요한 기술도 RFC로 시작)\n\n- IETF (Internet Engineering Task Force)\n인터넷 표준을 만드는 국제 기구\n새로운 프로토콜이나 보안 규칙을 논의하고 표준으로 정함\n\n#### 8️⃣ Infrastructure that provides services to applications\n애플리케이션에 서비스를 제공하는 인프라\n\n물리적이고 기술적인 자원들이 모여서 어떤 시스템이나 서비스를 운영할 수 있게 해주는 기반을 말함\n\n즉, 인프라는 **하드웨어(서버, 라우터)** 와 **소프트웨어(프로토콜, 시스템)** 를 모두 포함\n\n---\n\n## Protocols (프로토콜)\n- #### Human protocols (사람 간의 프로토콜)\n사람들이 서로 소통할 때도 **정해진 규칙(프로토콜)** 이 있음\n\n예를 들어\n- \"몇 시야?\" (정보 요청)\n- \"질문 있어.\" (대화 시작)\n- 자기소개 (처음 만날 때 인사)\n\n-> 우리가 대화할 때도 말하는 순서와 방식을 지키는 것처럼, 네트워크에서도 이런 규칙이 필요\n\n- #### Network protocols (네트워크 프로토콜)\n사람 대신에 **컴퓨터(기기)** 가 서로 소통할 때 사용하는 규칙\n인터넷에서 이루어지는 모든 통신 활동은 이 규칙에 따라 움직임\n\n\n**프로토콜이 정의하는 것**\n\n- `메시지 형식 (format)` :\n메시지가 어떤 구조로 이루어져 있는지 (ex. 헤더, 페이로드)\n\n- `메시지 순서 (order)` :\n어떤 메시지를 먼저 보내고, 다음에 무엇을 보낼지\n\n- `전송 및 수신 시 동작 (actions)` :\n메시지를 보낼 때와 받을 때 각각 무슨 행동을 해야 하는지\n\n> 즉 프로토콜은 컴퓨터 간 통신에서 메시지의 형식, 순서, 행동을 정의하는 규칙이다.\n\n---\n\n## Network Edge (네트워크 엣지)\n네트워크 엣지는 인터넷의 끝부분으로, `사용자가 인터넷에 접속하는 지점(호스트)`이다.\n\n- Hosts: Clients and Servers\n\n`클라이언트`: 인터넷을 통해 서비스를 요청하는 장치 (예: 스마트폰, PC)\n`서버`: 인터넷에서 서비스를 제공하는 장치 (예: 웹 서버, 데이터베이스 서버)\n\n`클라이언트`와 `서버`는 서로 데이터를 주고받으며 인터넷 상에서 서비스를 주고받는 관계다. 해당 수업에서는 둘의 구별을 두지 않는 걸로 가정\n\n- Servers Often in Data Centers : 서버는 보통 데이터 센터에  존재\n\n즉, 네트워크 엣지는 클라이언트(사용자)와 서버가 서로 소통하는 지점, 그리고 이 지점에서 호스트들이 연결되고 통신한다.\n\n- Access networks, physical media (액세스 네트워크, 매질) : \n액세스 네트워크는 사용자가 인터넷에 접속하는 부분이고, 유선 또는 무선 링크를 통해 데이터를 주고받음\n\n---\n\n\n## Network core (네트워크 코어)\ninterconnected routers: 서로 연결된 라우터들\n\n→ 네트워크 간에 여러 라우터들이 서로 연결되어 데이터를 목적지까지 전달함\n\nnetwork of networks: 네트워크들의 네트워크\n\n→ 인터넷은 작은 네트워크들이 모여서 이루어진 거대한 네트워크\n\n`네트워크 코어`: 여러 라우터들이 서로 연결되어 다양한 네트워크를 하나로 묶는 중심 부분\n\n---\n\n## Transmission rate(전송률) & Bandwidth(대역폭)\n- `Transmission rate(전송률)`\n\n`bps(단위)` : bit / second -> 1/S = ----------\n초당 몇개의 비트를 네트워크를 통해서 보낼 수 있는지\nEx 강한 압력으로 파이프에 물을 넣으면 1초 동안 물을 더 많이 보낼 수 있게 된다.\n\n- `Bandwidth(대역폭)`\nEx 동일한 압력으로 물을 넣을 때 파이프의 직경이 클수록 더 많은 물을 보낼 수 있게 된다.\n\n즉 개념적인 부분에서 대역폭은 네트워크가 최대로 전송할 수 있는 용량이며, 전송률은 전송되는 데이터의 속도를 의미한다.\n\n이 차이를 알 필요가 있다.\n\n---\n\n## FDM(Frequency Division Multiplexing)\n- 하나의 통신 채널을 여러 개의 주파수 대역으로 나누어 여러 신호를 동시에 전송하는 방식이다.\n\n- 각 신호는 서로 다른 주파수 대역을 사용하므로 `간섭` 이 없다.\n\n- 예를 들어 무전기와 라디오 같이 특정 대역을 정하면 그 대역으로 통신할 수 있게 된다.\n\n- 멀티플렉싱을 할 수 있는 방법으로 1. 시간대를 나누거나 2. 주파수 대역을 나눈 방식이 있다.\n\n![](https://velog.velcdn.com/images/ghkdehs/post/dbec666c-bb7f-46ef-aa07-7d6c94605d8c/image.png)\n\n\n## OSI 7 Layer\n\n![](https://velog.velcdn.com/images/ghkdehs/post/dc03e147-a1f7-4c90-b5a7-ba9c71b74771/image.png)\nISO/OSI reference model 이라고 부른다.\n\n- 국제표준기구(ISO)에서 컴퓨너 네트워크를 구성할 때 어떤 것들이 필요한지 모든 기능들을 상세하게 분석한 후, 이 정도의 기능들을 다루는 `Layer`가 있어야 완전한 통신이 된다고 정의함\n\n해당 강의 에서는 Top-Down 방식으로 진행 예정이며, 간단한 설명만 아래에서부터 시작\n\n####  1️⃣ Physical\n실제 데이터가 전송되는 물리적인 매체(케이블, 전파, 광섬유 등)를 다루는 계층\n\n#### 2️⃣ Link \n물리 계층(1계층)에서 받은 데이터를 신뢰성 있게 전송하도록 관리하는 계층\n\n어딘가에 데이터를 보낼 때 내가 사용할 수 있는 media(데이터가 전송되는 매체)`을 할당해준다.\n= 데이터를 보낼 경로를 MAC 주소를 통해 어떤 장치로 보낼지 결정하고, 그 경로(유선, 무선)에 따라 데이터를 전송하는 걸 의미\n\n\n#### 3️⃣ Network\n어떠한 목적지까지의 데이터를 전달하는 `라우팅`을 담당한다.\n> **라우팅** : 네트워크 내에서 데이터를 전달할 경로를 설정하고 관리하는 과정\n\n\n- 즉, 네트워크간의 연결에서 어떤 경로로 데이터를 보낼지 결정하는 것이 3계층의 역할이다.\n\n\n- 예를 들어 대구에서 서울로 간다고 가정했을 때, 어떤 도시를 거쳐서 갈 것인지 네비게이션이 최적의 경로를 설정하는 경우\n\n#### 4️⃣ Transport\nTransport Layer는 데이터를 `보낸 사람`과 `받은 사람` 사이에서 정확하고 신뢰성 있는 통신을 보장하는 역할을 한다.\n\n- 주요 기능\n  - 큰 데이터를 작은 데이터로 패킷화\n  - 데이터 손상 유무를 체크하고, 이상이 있을 시 재전송 요청\n  - 데이터의 양을 조절해서 흐름 제어\n  - 데이터 전송 시작 전에 연결을 설정하고, 받은 후 연결 종료\n\n이 모든 특징은 택배 회사를 통해 택배를 보내는 흐름과 유사하다.\n\n#### 5️⃣ Session\n데이터 교환의 흐름을 제어하고, 동기화나 복구를 처리하는 역할\n\n#### 6️⃣ Presentation\n데이터를 사람이 이해할 수 있는 형태로 변환 (부호화, 압축, 암호화)\n\n- 주요 기능\n  - 데이터 변환 (Data Translation) : 서로 다른 시스템 간 데이터 변환\n  - 암호화/복호화 (Encryption/Decryption) : 보안 강화 (예: SSL/TLS)\n  - 압축 (Compression) : 전송 속도 향상 (예: ZIP, MP3, JPEG)\n\n#### 7️⃣ applications\n사용자가 직접 접하는 소프트웨어나 서비스 제공\n\n---\n\n## Host : packet transmission delay (패킷 전송 지연률)\n\n패킷 전송 지연 계산\n\n어떠한 패킷을 전송하는 데 걸리는 시간은 아래와 같이 계산\n\n![](https://velog.velcdn.com/images/ghkdehs/post/eb6be68d-3384-4293-b232-5c8218a06f58/image.png)\n\nL: 패킷의 크기 (비트 단위)\n\nR: 링크의 전송 속도 (비트/초)\n\nl개의 비트로 r이라는 bps를 통해 걸리는 시간을 계산하는 것이 곧 지연률이 된다.\n\n\n만약 packet transmission delay를 구할 때 단위는 `초`가 나와야 된다. \n\n\n---\n\n## Link : Guided media, Unguided media\n\n이 둘의 기준을 어떠한 정보를 전송하는데 이 정보를 누구나 받을 수 있냐와 없냐의 차이로 볼 수 있다.\n\n- `Guided media` : 어떠한 물리적인 전선, 케이블을 통해 전송되는 매체\n  - 전선, 광섬유 케이블(Fiber)\n\n- `Unguided media` : 물리적인 전선 등 없이 공기나 진공을 통해 자유롭게 전송하는 방식\n  - 라디오\n\n### Link : Physical media\n- Coaxial cable\n- Fiber optic cable\n- Wireless radio \n  - 물리적인 전선을 쓰지는 않지만 `전파` 라는 신호가 실제의 공기를 통해 전달되기 때문에 Physical media의 일종이다.\n  - **`half-duplex`** : 양방향 통신에서 한 번에 하나의 방향으로만 데이터 전송이 가능한 방식\n  예를 들어 무전기가 있다.\n","excerpt":"<h2 id=\"컴퓨터-네트워크-개요\">컴퓨터 네트워크 개요</h2>\n\n"},{"title":"「 ComputerNetwork 」 네트워크 계속, 인터넷 구조, 패킷 딜레이","url":"/computernetwork/2025/03/16/ComputerNetwork01/","content":"## Network core\n<!--more-->\n\nISP 내부에는 `Network core`와 `Network Edge`가 있다.\n\n어떠한 정보를 보낼 때 네트워크 코어에서 데이터를 처리하는 두 가지 전송 방식이 존재한다.\n\n1. Circuit Switching - 고정된 경로(회선) 를 설정하고, 데이터가 이 경로를 따라 전송되는 방식 \n2. Packet Switching - 박스에 정보를 담아 전송하는 방식\n\n`스위치`나 `라우터`가 있어야 현재의 네트워크에서 다른 네트워크로 전송이 가능함 \n\n- Forwarding (전달하다) - 패킷을 라우터에서 라우터, 다른 호스트로 전달하는 과정을 의미 \n    - 즉 데이터를 생성한 사람은 내가 아니며, 누군가로 부터 받은 데이터를 다른 쪽으로 전송하는 것이다.\n\n### Packet-switching: store-and-forward\n\n![](https://velog.velcdn.com/images/ghkdehs/post/cc6eab54-5b9f-47be-8497-b0c548c6829a/image.png)\n\nPacket Swtiching 방식은 store and forward 방식으로 작동한다.\n\nsource에서 L개의 비트로 이루어진 패킷을 보내려고 하면, 라우터 내부의 `buffer`에 해당 패킷을 저장 후 라우터는 버퍼에 들어온 순서대로 패킷을 정해진 destination으로 `전달한다` .\n\n패킷전송지연률 = L / R\n\n`End to End Delay` : 데이터가 출발지에서 목적지까지 전달되는 데 걸리는 전체 시간 = 2L/R\n\n라우터 하나를 거칠 때 2L 이며 이후 N개 만큼 곱한다.\n\n`hop` : 패킷의 이동 단위\n\n위 그림에서 source에서 라우터까지의 한 번의 이동이 1hop이 된다.\n\n\n### Packet-switching: queueing delay, loss\n![](https://velog.velcdn.com/images/ghkdehs/post/af6425b3-da50-4655-9e53-62ff0cbf3140/image.png)\n\n원래 Packet switching은 여러 개의 컴퓨터가 하나의 스위치나 라우터에 연결되어서 네트워크를 좀 더 효율적으로 쓰기 위함으로 위 그림이 좀 더 현실적이라 할 수 있다.\n\n위의 그림예시로 A컴퓨터에서 패킷을 보내는 속도가 100Mb/s고 라우터가 처리하는 속도가 1.5Mb/s 일 때 라우터의 buffer가 전부 차면 아직 처리되지 못한 패킷을 삭제하고 새로운 패킷이 들어오게 되는데 이를 `loss` 라고 칭한다.\n\n### Two key network-core functions\n\n네트워크 코어의 두 가지 주요 기능\n\n![](https://velog.velcdn.com/images/ghkdehs/post/b30c9a89-7e2b-4f76-9f56-ce03b5f9ce9e/image.png)\n\n위 이미지는 여러 라우터 간 연결을 보여주며, 라우팅 알고리즘이 패킷의 최적 경로를 선택하는 과정을 나타낸다\n\n- Forwarding (포워딩)\n로컬 작업 - 라우터 하나의 관점에서 보는 것\n    - 패킷의 헤더 값에 따라 **local forwarding table(로컬 포워딩 테이블)** 을 참조하여 출력 링크를 결정한다\n    - 예를 들어, 패킷의 헤더 값이 \"0111\"이라면, 테이블에 따라 출력 링크 \"2\"로 이동한다.\n\n\n- Routing (라우팅)\n글로벌 작업: 라우터들 끼리 이어져있는 전체적인 구성에서의 관점으로 보는 것\n    - 이는 네트워크 전체에서 경로를 설정하며, 라우팅 알고리즘을 통해 진행된다\n\n### Circuit switching: FDM and TDM\n\n![](https://velog.velcdn.com/images/ghkdehs/post/577d8c93-c27d-484a-84fa-f235da93f9e4/image.png)\n\n하나의 네트워크를 다수의 유저가  통신 자원인 `주파수` 와 `시간` 을  활용해서 효율적으로 나눠 쓰도록 하기 위한 기술\n\n- Frequency Division Multiplexing (FDM)\n    - 주파수를 여러 개의 작은 대역으로 나눠서 각각 할당하는 방식\n    - 각 사용자는 특정 주파수 대역을 계속 사용 가능\n- Time Division Multiplexing (TDM)\n    - 시간을 여러 개의 슬롯으로 나누고, 각 사용자에게 특정 시간 동안만 전송 기회를 주는 방식\n    - 모든 사용자가 넓은 주파수 대역을 사용할 수 있지만, 특정 시간 슬롯에서만 전송 가능\n\nfdm을 쓰든 tdm을 쓰든 데이터의 총량(엔트로피)는 정해져있음 가로로 쓰냐 세로로 쓰냐의 차이일 뿐이다\n\n### Packet switching VS circuit switching\n\n결론적으로 패킷스위칭이 좋다\n\n대부분의 부분에서 패킷 스위칭으로 전환이 되어가는 중임 (전화까지도)\n\n---\n\n## Internet structure\n\n과거의 인터넷 구조에서는 네트워크 간의 연결을 하나씩 설정하고 직접 연결하는 방식이었음\n\n![](https://velog.velcdn.com/images/ghkdehs/post/9cba6c73-ff5d-4673-b40b-7b0ffa4bc99a/image.png)\n\n허나 이러한 방식은 원래는 각각의 액세스를 직접 연결해서 사용했기 때문에 그 개수의 제곱만큼의 연결선이 발생해서 비용적인 측면에서 매우 비효율적이었음\n\n\n![](https://velog.velcdn.com/images/ghkdehs/post/8a003087-b36c-4d6e-bf74-879d0ad0eadd/image.png)\n\n이후 중앙 ISP가 생기고, 트래픅 흐름을 효율적으로 관리할 수 있게 되었다.\n\n![](https://velog.velcdn.com/images/ghkdehs/post/1b865831-b8b0-463a-942d-85ba7303e440/image.png)\n\n하지만 글로벌 ISP는 다양하게 존재하고, 글로벌 ISP간의 데이터 교환을 위해 `IXP(Internet Exchange Point)`를 두어 다른 지역은 ISP여도 서로간의 데이터를 공유할 수 있게 됐다.\n\n\n### 인터넷 계층 구조\n![](https://velog.velcdn.com/images/ghkdehs/post/7f25a009-2e8b-4435-8220-e533e5517ef3/image.png)\n\n- `Tier 1 ISP`\nTier 1 ISP는 국제적 및 국가적 단위에서 인터넷 제공하는 상위 ISP\n\n- `Content Provider Networks (CPN)`\n    - 인터넷 콘텐츠를 제공하는 서비스나 플랫폼이 운영하는 네트워크\n    - CPN 또한 사용자가 접속하려고 할떄 중개자인 ISP를 거쳐서 데이터를 받을 수 있다.\n\n- `IXP`\nIXP는 여러 네트워크가 서로 데이터를 교환하는 물리적 장소\n\n- `Reginal ISP`\n    - 지역적으로 인터넷 서비스를 제공하는 ISP 예로 한국의 kt, lg, u+ 등이 있다.\n    - Tier 1 ISP나 IXP와 연결되어 있으며, Access ISP를 통해 최종 사용자에게 서비스를 제공\n\n- `Access ISP`\n가장 하위 계층의 ISP로 지역 ISP를 통해 인터넷에 연결됩니다.\n\n---\n\n## Packet Delay\n\nPacket delay는 패킷이 출발지에서 목적지까지 전송되는 동안 발생하는 총 지연 시간을 의미하며, 크게 4가지 주요 원인으로 나눌 수 있다.\n\n![](https://velog.velcdn.com/images/ghkdehs/post/a443faa8-2a3e-4dbd-bc8b-9e22dd1f4ff1/image.png)\n\n1.Processing delay\n연산이 복잡한 알고리즘을 돌리거나 창을 여러개 켜놓을 때에 발생하는 지연, 즉 연산을 처리할 때 걸리는 지연시간\n\n2.queueing delay\n라우터 버퍼에서 패킷이 출력되는 동안 지연되는 시간\n\n3.Transmission delay\n패킷이 전송될 때 걸리는 시간\n\n4.propagation\n거리 / 전파 속도\n\n즉 `패킷의 전체 지연 시간`은 네 가지 지연 요소의 합으로 구할 수 있다.\n\n- 이 네 가지 지연요소 외에 남은 요소가 있다면?\n-> 목적지 라우터로부터 확답을 받을 때 까지 걸리는 딜레이가 있다.\n\n\n- 반대로 확답을 받지못해 재전송한다면? \n-> trans , porp 그리고 Echo Request를 받는 시간까지 추가 지연 발생\n\n## Caravan analogy\n\n![](https://velog.velcdn.com/images/ghkdehs/post/014cf9a8-1ca3-43cb-8470-a83b0728d552/image.png)\n\n여기 자동차 한 대는 네트워크에서의 `비트`를, 10대의 자동차로 이루어진 카라반은 `패킷`을 의미한다\n\n속도와 처리 시간:\n\n- 자동차는 시속 100km로 이동한다 (전송 속도)\n\n- 톨게이트(라우터)는 한 대의 자동차를 처리하는 데 12초가 걸린다. (비트 전송 시간).\n\n> 첫 번째 톨게이트를 통과한 카라반이 두 번째 톨게이트에 도착하여 정렬되기까지 걸리는 시간은?\n\n\n- 첫 번째 톨게이트에서 카라반 처리 시간:\n\n각 자동차를 처리하는 데 12초가 걸리므로, 전체 카라반(10대)을 처리하는 데 \n`12 × 10 = 120` -> 120초\n\n- 두 번째 톨게이트까지 이동 시간:\n\n마지막 자동차가 첫 번째 톨게이트를 떠난 후 두 번째 톨게이트까지 이동하는 데 걸리는 시간은 \n\n`100km/(100km/hr)` -> 1시간 \n\n\n- 총 소요 시간:\n\n첫 번째 톨게이트에서 카라반을 모두 처리하는 데 걸린 시간(120초 = 2분)과 마지막 자동차가 두 번째 톨게이트까지 도달하는 데 걸린 시간(1시간)을 합산하면 총  62분이 소요된다.\n\n## Packet queueing delay\n\n![](https://velog.velcdn.com/images/ghkdehs/post/600abe2e-7fff-488e-8812-f7b9927aba78/image.png)\n\n\nR: 링크 대역폭 (bps, 초당 비트 전송 속도)\n\nL: 패킷 길이 (bits, 패킷의 크기)\n\na: 평균 패킷 도착률 (초당 도착하는 패킷 수)\n\n\n\nLa/R≈0: 트래픽 강도가 낮아 평균 큐잉 지연이 작음.\n\nLa/R→1: 트래픽 강도가 높아져 평균 큐잉 지연이 커짐.\n\nLa/R>1: 도착하는 작업량이 서비스 가능한 양을 초과하여 지연 시간이 무한대가 됨.\n\n## Packet loss\n\n- 버퍼 내부의 원래 전송되어야 하는 패킷이 네트워크에서 사라지는 것을 의미\n\n- 패킷이 도착하는 속도가 보내는 속도보다 빠를때 발생 \n\n- 일정 버퍼 메모리가 초과되면 `패킷이 삭제되는데 (buffer overwrite)`이를 `packet loss` 라고함","excerpt":"<h2 id=\"network-core\">Network core</h2>\n\n"},{"title":"「 ComputerNetwork 」 네트워크 보안 및 계층화","url":"/computernetwork/2025/03/18/ComputerNetwork_03/","content":"## Network Security\n\n<!--more-->\n\n우선 과거에는 보안이 중요하지 않았음, 애초에 네트워크 간 통신을 하기도 어려웠던 상황이었다.\n\n즉, 누군가의 정보를 탈취한다는 개념에 집중할 수 없었다.\n\n하지만 과거와 달리 인터넷 보안에 신경을 쓸 시기가 왔는데, OSI 7 layer의 모든 부분에서 보안을 신경쓰도록 바뀌었다.\n\n고 단계의 계층으로 갈 수록 암호화의 기술도 고도화할 수 있게 됐다.\n예를 들어, 파일의 암호화 등\n\n## Malware \n- `Mal`: 그리스어로 나쁜 ,`ware`: software = 나쁜 소프트웨어\n\nVirus : 사용가자 특정 개체를 실행시 감염\nWorm : 사용자의 행동과 무관하게, 직접 수신하면 감염됨\n\nSpyware : 사용자의 컴퓨터에 몰래 접근하여 권한을 얻어내는 멀웨어\n\nDDos : DDOS는? `좀비 컴퓨터(botnet)`를 넓은 영역에 펼쳐서  연결된 네트워크들에게 특정 시간에 불필요한 패킷을 마구잡이로 보내는 것\n\n\n### Denial of service\n\n\n- Dos: `Denial of Service(서비스를 거절한다.)`라는 뜻의 약자\n\n공격자가 **가짜 트래픽(bogus traffic)** 으로 리소스(서버, 대역폭)를 과부하(overwhelming) 시켜, 정상적인 사용자(legitimate traffic)가 이를 사용할 수 없도록 만드는 공격\n\n### Packet interception\n\n`Packet interception` :  네트워크에서 전송 중인 패킷을 가로채는 행위\n\n`Packet Sniffing` : Interception의 한 방식으로 네트워크에서 전송되는 패킷을 `엿보고(Sniffing)` 분석하는 행위\n\n- 좀더 발전된 사이버 공격으로 `일반 도스 공격`은 예를 들어 은행 업무를 아예 사용하지 못하도록 마비시키고, `스니핑`은 특정 정보를 빼내오는 기술임\n\n\n\n![](https://velog.velcdn.com/images/ghkdehs/post/28fbfe3b-8733-48eb-b9df-52dc88987fa8/image.png)\n\n로그인 정보가 a로만 가야되는데 중간의 c가 정보를 탈취하는(interception) 것을 보여준다.\n\n### fake identity\n\nIP spoofing: 공격자가 가짜 IP주소를 사용하여 자신을 다른 시스템처럼 보이게하는 기술이다.\n\n![](https://velog.velcdn.com/images/ghkdehs/post/296de5ec-710e-4fb6-bea7-211d3c86dba2/image.png)\n\n- 공격자가 적극적으로 악의적인 행동을 한다.\n\n- A가 은행서버, B는 피해자 \n\n- c가 스니핑을 통해서 정보를 획득 후,  c가 a인 것처럼 행동, 원래는 c가 a를 공격해야 하는데 그 반대가 되는 경우임\n\n---\n\n## 네트워크의 계층화\n\n1. **복잡한 시스템의 조직화**\n\n- 네트워크와 같은 복잡한 시스템은 여러 구성 요소(호스트, 라우터, 링크, 애플리케이션, 프로토콜 등)로 이루어져 있음.\n\n- 이러한 시스템은 **`계층화`** 를 통해 관리하고 이해하기 쉽게 조직할 수 있음.\n\n2. **항공 여행 과정의 예시**\n\n![](https://velog.velcdn.com/images/ghkdehs/post/fa93a7c7-21d3-4d2b-abdf-d9c327b40725/image.png)\n\n항공 여행 과정에서 각 단계(티켓 구매, 수하물 체크, 비행기 이륙 등)를 네트워크 계층화에 빗대어 설명할 수 있다.\n\n\n3. **왜 계층화가 필요하며, 수 많은 계층을 만들까?**\n\n - 계층화는 복잡한 시스템을 더 쉽게 관리하고 단순화하기 위해 사용된다.\n \n - 시스템을 여러 개의 잘 정의된 계층으로 나누어 각 계층이 구조적으로 상호작용하도록 만든다.\n\n - 여러 가지 계층화 모델이나 구성 방법을 많이 시도한 후, 표준화된 규격을 만들어서 네트워크를 구성하는 것이 그 이유\n\n\n\n## Internet protocol stack\n\n![](https://velog.velcdn.com/images/ghkdehs/post/5fcb4cc4-e99d-4400-b160-8e9ac4dff249/image.png)\n\n- internet protocol stack에서는 Application 계층이 presentation과 session 계층을 모두 포함한다.\n\n**OSI 7layer와 차이점?**\n\n- `OSI 7계층`은 네트워크 통신의 각 단계를 매우 세분화하여 정의한 이론적인 모델이며, `인터넷 프로토콜 스택`은 실제로 인터넷에서 데이터를 전송하는 데 사용되는 프로토콜을 기반으로 한 실용적 모델이다.\n\n- `인터넷 프로토콜 스택`은 OSI 모델을 참고하여 설계되었지만, OSI 모델처럼 복잡하게 구분된 계층을 사용하지 않고, 계층을 통합하여 효율성을 추구한다.\n\n## Encapsulation\n\nEncapsulation : 캡슐화\n\n데이터를 네트워크를 통해 전송할 때, 각 계층은 자신만의 정보를 담은 **헤더(header)** 를 추가하며, 계층이 내려갈 때마다 헤더가 붙는다.\n\n\n\n![](https://velog.velcdn.com/images/ghkdehs/post/c2f95679-d149-4a6f-993d-d550485d93e7/image.png)\n\n","excerpt":"<h2 id=\"network-security\">Network Security</h2>\n\n"}]