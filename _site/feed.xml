<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-04-19T17:24:20+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Ukja2</title><subtitle>Practice &amp; Practice</subtitle><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><entry><title type="html">뽑아주소서 서비스 동작 흐름</title><link href="http://localhost:4000/spring/AIproject/" rel="alternate" type="text/html" title="뽑아주소서 서비스 동작 흐름" /><published>2025-04-13T02:00:00+09:00</published><updated>2025-04-13T02:00:00+09:00</updated><id>http://localhost:4000/spring/AIproject</id><content type="html" xml:base="http://localhost:4000/spring/AIproject/"><![CDATA[<h3 id="서비스-동작-흐름도-기록용">서비스 동작 흐름도 기록용</h3>
<!--more-->
<ol>
  <li>
    <p>사용자가 질문을 입력
→ 프론트엔드에서 입력값은 단순한 string 형태로 존재</p>
  </li>
  <li>프론트에서 fetch() 함수로 백엔드에 전송
→ 이때 자바스크립트에서 JSON.stringify()를 사용해
→ JSON 형태로 포장해서 전송됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "message": "자기소개서 도와줘!"
}
</code></pre></div>    </div>
  </li>
  <li>
    <p>백엔드는 이 JSON을 <code class="language-plaintext highlighter-rouge">@RequestBody</code>로 받아 처리
→ <code class="language-plaintext highlighter-rouge">"message"</code> 값을 매개변수로 꺼냄</p>
  </li>
  <li>
    <p>그 값을 바탕으로 GPT API에 보낼 본문(JSON)을 생성
→ <code class="language-plaintext highlighter-rouge">"model"</code>, <code class="language-plaintext highlighter-rouge">"messages"</code>, <code class="language-plaintext highlighter-rouge">"max_tokens"</code> 등 GPT가 이해할 수 있는 구조로 만듦
→ 헤더(Authorization, Content-Type)도 포함해서 GPT에게 POST 요청</p>
  </li>
  <li>GPT는 응답(JSON)을 반환함</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "choices": [
    {
      "message": {
        "role": "assistant",
        "content": "이렇게 작성해보세요!"
      }
    }
  ]
}
</code></pre></div></div>

<ol>
  <li>백엔드는 이 응답을 파싱하여 “content”만 추출
→ 그 내용을 다시 JSON으로 포장해서 프론트에 반환
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "response": "이렇게 작성해보세요!"
}
</code></pre></div>    </div>
  </li>
  <li>프론트는 response 값을 받아 사용자에게 보여줌</li>
</ol>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Spring" /><category term="Spring" /><summary type="html"><![CDATA[서비스 동작 흐름도 기록용]]></summary></entry><entry><title type="html">의존성 주입</title><link href="http://localhost:4000/spring/Dependency_Injection/" rel="alternate" type="text/html" title="의존성 주입" /><published>2025-04-10T02:00:00+09:00</published><updated>2025-04-10T02:00:00+09:00</updated><id>http://localhost:4000/spring/Dependency_Injection</id><content type="html" xml:base="http://localhost:4000/spring/Dependency_Injection/"><![CDATA[<h2 id="의존성-주입dependency-injection-di">의존성 주입(Dependency Injection, DI)?</h2>

<p>이는 Spring에서 객체를 직접 만들지 않고, 필요한 객체를 외부에서 주입받는 것이다.</p>

<!--more-->

<p>예를 들어</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Car {
    private Engine engine = new Engine(); // 직접 생성
}
</code></pre></div></div>
<p>Car 객체는 스스로 Engine을 만들고 있다. 이러면 Engine을 바꾸거나 테스트할 때 매우 불편하게 되는데</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
public class Car {
    private Engine engine;

    public Car(Engine engine) {
        this.engine = engine;
    }
}

</code></pre></div></div>

<p>위의 코드처럼 외부에서 engine을 주입함으로서 Engine 객체를 직접 만들지 않아도 된다.</p>

<hr />

<h2 id="의존성-주입-방식">의존성 주입 방식</h2>

<h3 id="1-필드-주입-방식">1. 필드 주입 방식</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
@Component
public class Car {

    @Autowired
    private Engine engine;
}
</code></pre></div></div>

<p>스프링에서 제공하는 @Autowired 어노테이션을 통해 필드에 주입한다.</p>

<ul>
  <li>final을 사용할 수 없어 불변성을 보장하지 못한다는 단점이 있다.</li>
  <li>하지만 가독성이 좋은편</li>
</ul>

<h3 id="2-생성자-주입-방식">2. 생성자 주입 방식</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Component
public class Car {

    private final Engine engine;

    @Autowired  
    public Car(Engine engine) {
        this.engine = engine;
    }
}
</code></pre></div></div>
<ul>
  <li>final을 사용할 수 있어 불변성을 보장한다.</li>
  <li>테스트하기 용이하다.</li>
  <li>가장 보편적으로 사용된다.</li>
</ul>

<p>### 3. 세터 주입 방식</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
 @Component
public class Car {

    private Engine engine;

    @Autowired
    public void setEngine(Engine engine) {
        this.engine = engine;
    }
}

</code></pre></div></div>

<p>이렇게 set 메서드에 @Autowired 붙여서 주입하는 방식으로</p>
<ul>
  <li>필수는 아닌 의존성, 선택적으로 넣고 싶을 때 사용한다.</li>
</ul>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Spring" /><category term="Spring" /><summary type="html"><![CDATA[의존성 주입(Dependency Injection, DI)? 이는 Spring에서 객체를 직접 만들지 않고, 필요한 객체를 외부에서 주입받는 것이다.]]></summary></entry><entry><title type="html">Map 인터페이스</title><link href="http://localhost:4000/java/JavaMap/" rel="alternate" type="text/html" title="Map 인터페이스" /><published>2025-04-03T03:00:00+09:00</published><updated>2025-04-03T03:00:00+09:00</updated><id>http://localhost:4000/java/JavaMap</id><content type="html" xml:base="http://localhost:4000/java/JavaMap/"><![CDATA[<h4 id="map이란">Map이란?</h4>
<p>자바에서 Map은 <strong>Key(키)</strong> 와 <strong>Value(값)</strong> 의 쌍으로 데이터를 저장하는 자료구조</p>

<!--more-->

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
map.put("name", "재욱");
map.put("age", 25);
map.put("isStudent", true);
</code></pre></div></div>

<ul>
  <li>
    <p>Map 인터페이스는 제네릭 구조를 가지며,<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt;</code> 의 형태를 띤다.</p>
  </li>
  <li>
    <p>또한 제네릭은 오직 객체만 받기 때문에, Value에는 래퍼 클래스만 작성할 수 있다.</p>
  </li>
  <li>
    <p>위 예제에서 HashMap은 Map 인터페이스를 구현한 클래스중 하나이며, 종류가 다양하지만 가장 기본적인 형태이다.</p>
  </li>
  <li>
    <p>위 예제에서는 Key가 String 타입이고, Value는 어떤 타입이든 저장할 수 있게 Object 타입으로 지정했다.</p>
  </li>
</ul>

<p>아래는 위의 예시를 그림으로 나타낸 형태이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌────────────┬────────────┐
│   Key      │   Value    │
├────────────┼────────────┤
│  "name"    │  "재욱"     │
│  "age"     │  25        │
│  "isStudent" │ true     │
└────────────┴────────────┘
</code></pre></div></div>

<p>이런 형태로 저장된다.</p>

<p>Map의 특징으로는</p>
<ol>
  <li>Key 값은 중복될 수 없다.</li>
  <li>Value는 중복될 수 있다.</li>
  <li>순서를 보장하지 않는다. (LinkedHashMap 클래스는 보장함)</li>
</ol>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Java" /><category term="Java" /><summary type="html"><![CDATA[Map이란? 자바에서 Map은 Key(키) 와 Value(값) 의 쌍으로 데이터를 저장하는 자료구조]]></summary></entry><entry><title type="html">「 Network 」 5주 1차시, Application Layer - Email</title><link href="http://localhost:4000/network/ComputerNetwork-Email/" rel="alternate" type="text/html" title="「 Network 」 5주 1차시, Application Layer - Email" /><published>2025-04-01T03:00:00+09:00</published><updated>2025-04-01T03:00:00+09:00</updated><id>http://localhost:4000/network/ComputerNetwork-Email</id><content type="html" xml:base="http://localhost:4000/network/ComputerNetwork-Email/"><![CDATA[<h3 id="email">Email</h3>
<p>Email의 세가지 구성요소</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/6c98f74d-a106-48fd-8afa-b9a7b95eceda/image.png" alt="" /></p>

<!--more-->
<ol>
  <li>user agents : 사용자를 대신하여 일을 수행하는 것 (쉽게 서비스에 가입한 유저라고 생각)</li>
  <li>mail servers : 메일 서버</li>
  <li>simple mail transfer protocol: SMTP : 이메일 전송을 위한 프로토콜.</li>
</ol>

<p><strong>app 계층에서는 이세가지가 있어야 통신이 가능</strong></p>

<h4 id="user-agent-aka-mail-reader라고-한다">User Agent (a.k.a Mail reader라고 한다.)</h4>

<ul>
  <li>사용자는 이메일을 작성하고 편집하며, 받은 이메일을 읽는 역할을 담당하는 프로그램을 사용한다.
    <ul>
      <li>예를 들어 Gmail, Thunderbird 등을 사용</li>
    </ul>
  </li>
  <li>메일 서버와의 상호작용:
    <ul>
      <li>사용자가 <strong>메일을 보낼 때</strong>, 메일 서버에 메일을 전송하고</li>
      <li>사용자가 <strong>메일을 받을 때</strong>는 메일 서버에서 메일을 받아 읽음.</li>
    </ul>
  </li>
</ul>

<h4 id="e-mail-mail-servers">E-mail: mail servers</h4>

<ul>
  <li>
    <p>Mailbox (메일박스) : 사용자의 메일박스에 받은 메시지를 저장한다.</p>
  </li>
  <li>Message Queue (메시지 큐)
    <ul>
      <li>발송 대기 중인 이메일이 메시지 큐에 저장된다.</li>
      <li>메일 서버가 이메일을 받은 후 다른 서버로 전달되기 전까지 큐에 저장되어 기다리게 된다.</li>
    </ul>
  </li>
  <li>동작 흐름:
    <ul>
      <li>
        <p>클라이언트 (Sending Mail Server): 이메일을 보낼 때, 발신 메일 서버에서 이메일을 보낸다.</p>
      </li>
      <li>
        <p>서버 (Receiving Mail Server): 이메일을 받을 메일 서버에서 수신된 이메일을 저장한다.</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="scenario-alice-sends-e-mail-to-bob">Scenario: Alice sends e-mail to Bob</h3>
<p><img src="https://velog.velcdn.com/images/ghkdehs/post/8ab3cc16-e56b-436e-b681-cc51e658066b/image.png" alt="" /></p>

<ol>
  <li><strong>Alice가 이메일을 작성한다</strong>
    <ul>
      <li>Alice는 자신의 <strong>사용자 에이전트(UA)</strong>를 사용해 이메일을 작성하고, 수신자 주소는 bob@someschool.edu로 설정한다.</li>
    </ul>
  </li>
  <li><strong>Alice의 사용자 에이전트가 메시지를 Alice의 메일 서버에 전송</strong>
    <ul>
      <li>이메일 메시지가 Alice의 메일 서버로 전송되고, 그 서버는 메시지를 <strong>발송 대기 중인 큐(message queue)</strong>에 저장한다.</li>
    </ul>
  </li>
  <li><strong>SMTP 클라이언트가 Bob의 메일 서버와 TCP 연결을 엶</strong>
    <ul>
      <li>Alice의 메일 서버는 SMTP 클라이언트 역할을 하며, Bob의 메일 서버와 TCP 연결을 설정한다.</li>
    </ul>
  </li>
  <li><strong>SMTP 클라이언트가 이메일 메시지를 TCP 연결을 통해 전송</strong>
    <ul>
      <li>Alice의 메일 서버는 이메일 메시지를 SMTP 프로토콜을 사용하여 TCP 연결을 통해 Bob의 메일 서버에 전송한다.</li>
    </ul>
  </li>
  <li><strong>Bob의 메일 서버는 메시지를 Bob의 메일박스에 저장</strong>
    <ul>
      <li>Bob의 메일 서버는 이메일을 수신하고, 그 이메일을 Bob의 메일박스에 저장한다.</li>
    </ul>
  </li>
  <li><strong>Bob은 자신의 사용자 에이전트를 호출하여 이메일을 읽음</strong>
    <ul>
      <li>Bob은 자신의 <strong>사용자 에이전트(UA)</strong>를 열어 수신된 이메일을 확인하고 읽는다.</li>
    </ul>
  </li>
</ol>

<h3 id="http-vs-smtp">HTTP vs SMTP</h3>

<ul>
  <li>
    <p>HTTP (Pull):</p>

    <ul>
      <li>
        <p>클라이언트가 요청을 보내고, 서버는 요청을 받은 후 그에 대한 응답을 보내는 방식입니다.</p>
      </li>
      <li>
        <p>즉, 클라이언트가 필요한 정보를 “끌어” 오듯이 요청하는 방식이다.</p>
      </li>
    </ul>
  </li>
</ul>

<p>예시: 웹 브라우저에서 웹 페이지를 요청하면, 웹 서버는 그 페이지를 응답하는 방식.</p>

<ul>
  <li>
    <p>SMTP (Push):</p>

    <ul>
      <li>메일 서버가 이메일을 “밀어넣기” 하듯이, 발신 서버가 수신 서버로 이메일을 보내는 방식이다.</li>
    </ul>
  </li>
</ul>

<p>예시: Alice가 Bob에게 이메일을 보낼 때, Alice의 메일 서버가 Bob의 메일 서버로 이메일을 전송하는 방식.</p>

<h4 id="smtp-특성">SMTP 특성</h4>

<ul>
  <li>SMTP는 지속적인 연결을 사용한다 (Persistent Connections)
    <ul>
      <li>SMTP는 지속적인 연결을 사용한다.. 즉, 이메일을 여러 번 전송할 때마다 매번 TCP 연결을 새로 열지 않고 한 번의 연결로 여러 이메일을 처리할 수 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="mail-message-format">Mail message format</h3>

<ul>
  <li>
    <p>SMTP는 이메일을 서버 간에 교환하는 프로토콜이다.</p>
  </li>
  <li>
    <p>이때 이메일 메시지는 구조는 <strong>RFC 82</strong>2**에 정의된 헤더와 본문으로 구성된다!</p>
  </li>
</ul>

<p>그 구조는 아래와 같다.</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/e6b9d320-420b-4f97-bff6-143f093c6cd4/image.png" alt="" /></p>

<ol>
  <li>헤더(header)
이메일의 정보를 설명하는 라인들로 구성된다.</li>
</ol>

<p>헤더 예시:</p>
<ul>
  <li>
    <p>To: 수신자 이메일 주소</p>
  </li>
  <li>
    <p>From: 발신자 이메일 주소</p>
  </li>
  <li>
    <p>Subject: 이메일 제목</p>
  </li>
</ul>

<ol>
  <li>본문 (Body)</li>
</ol>

<p>이메일 메시지의 본문(Body) 부분은 실제 <strong>“메시지”</strong> 가 들어있는 부분으로 이 본문은 ASCII 문자만 포함할 수 있다.</p>

<p>또한 본문 부분은 <strong>Payload(짐칸)</strong> 이라고 칭하기도 한다.</p>

<p>이에 더해 이메일 구조 뒷부분에는 <strong>Taylor</strong>라고 불리는 부분도 존재한다.</p>

<h3 id="mail-access-protocol">Mail access protocol</h3>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/bf1a5dfb-bc92-482e-bf85-77dc7057907c/image.png" alt="" /></p>

<ol>
  <li>SMTP (Simple Mail Transfer Protocol)
    <ul>
      <li>목적: 이메일 전송을 담당하는 프로토콜</li>
      <li>기능: 발신자 서버에서 수신자 서버로 이메일 메시지를 전달하는 역할을 한다.</li>
    </ul>
  </li>
  <li>IMAP (Internet Mail Access Protocol)
    <ul>
      <li>목적: 이메일 검색 및 관리를 담당하는 프로토콜</li>
      <li>기능: 서버에 저장된 이메일 메시지에 접근하여 검색, 삭제, 폴더 관리 등을 할 수 있다.</li>
    </ul>
  </li>
  <li>HTTP (Hypertext Transfer Protocol)
    <ul>
      <li>목적: 웹 기반 이메일 인터페이스 제공을 담당하는 프로토콜</li>
      <li>기능: Gmail, Hotmail, Yahoo!Mail 등과 같은 웹메일 서비스는 웹 브라우저를 통해 이메일을 전송하고 받을 수 있는 인터페이스를 제공한다.</li>
    </ul>
  </li>
</ol>

<h3 id="dns-domain-name-system">DNS: Domain Name System</h3>

<h4 id="1-사람과-인터넷에서-사용되는-식별자">1. 사람과 인터넷에서 사용되는 식별자</h4>

<ul>
  <li>
    <p>사람은 여러 식별자를 사용한다. 예를 들어, SSN(사회보장번호), 이름, 여권 번호 등이 있음</p>
  </li>
  <li>
    <p>인터넷에서는 각 장치가 IP 주소(32비트 주소)를 사용하여 데이터를 주고받는다. 이 IP 주소는 호스트를 식별하는 데 사용된다.</p>
  </li>
</ul>

<p>하지만 사람들은 IP 주소를 기억하기 어려운 경우가 많으므로, 더 쉽게 기억할 수 있는 도메인 이름을 사용한다.</p>

<h4 id="2-ip-주소와-도메인-이름-사이의-매핑">2. IP 주소와 도메인 이름 사이의 매핑</h4>

<p>질문: 사람들은 도메인 이름을 사용하고, 컴퓨터 네트워크에서는 IP 주소를 사용합니다. 이 두 가지를 어떻게 매핑할까?</p>

<p>이를 해결하는 시스템이 바로 DNS</p>

<h4 id="3-dns">3. DNS?</h4>
<ul>
  <li>
    <p>데이터베이스가 분산되어 있는 상황에서 특정 데이터베이스에 접근하기 위해 도메인을 적절한 IP 주소로 변환해 해당 데이터베이스 서버로 연결할 수 있도록 도와줌</p>
  </li>
  <li>
    <p>DNS는 인터넷의 가장자리에 위치한 시스템이다. 즉, 사용자가 요청을 보내고 응답을 받는 끝단에서 중요한 역할을 함, 클라이언트가 도메인 이름을 요청하고, 그에 대한 응답을 DNS 서버가 처리하여 반환하는 방식입니다.</p>
  </li>
</ul>

<h3 id="dns-a-distributed-hierarchical-database">DNS: a distributed, hierarchical database</h3>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/eed584fd-fbee-4765-b84b-3394f58007ba/image.png" alt="" /></p>

<h4 id="dns-구조-계층적-시스템">DNS 구조: 계층적 시스템</h4>

<ol>
  <li>
    <p>사용자가 특정 웹사이트를 방문하려고 할 때, 브라우저는 먼저 루트 DNS 서버에 요청을 보낸다.</p>
  </li>
  <li>
    <p>루트 서버는 해당 도메인의 TLD를 확인하고 적합한 TLD 서버로 연결</p>
  </li>
  <li>
    <p>이후 TLD 서버가 세부 도메인 정보를 가진 하위 DNS 서버로 요청을 전달하여 최종적으로 IP 주소를 반환한다.</p>
  </li>
</ol>

<h3 id="root-name-servers">Root Name Servers</h3>

<p>루트 네임 서버는 인터넷 DNS 계층구조의 최상위(root)에서 동작하는 서버로,
다른 네임 서버들이 도메인 이름을 해석할 수 없을 때 마지막으로 연락하는 서버(contact-of-last-resort) 역할을 한다.</p>

<p>즉 쉽게 말해서 인터넷에서 도메인 이름을 찾는 과정에서 가장 처음 참조되는 최상위 DNS 서버</p>

<h4 id="dnssec-domain-name-system-security-extensions">DNSSEC (Domain Name System Security Extensions)</h4>
<p>DNSSEC은 <strong>DNS 응답의 인증(Authentication)과 무결성(Integrity)</strong> 을 보장하는 보안 확장 기능이다.</p>

<ul>
  <li>DNSSEC이 없으면 공격자가 DNS 응답을 변조해서 가짜 사이트로 유도할 수 있음!</li>
</ul>

<h3 id="tld-top-level-domain-severs">TLD (Top-Level Domain) Severs</h3>
<p>TLD 서버는 최상위 도메인(.com, .org, .net, .edu 등)을 관리하는 네임 서버이다.</p>

<h3 id="authoritative-dns-servers">Authoritative DNS servers</h3>

<p>특정 도메인의 IP 주소를 최종적으로 제공하는 서버</p>

<p>즉 이를 정리하면</p>

<ul>
  <li>
    <p>Root DNS 서버: DNS에서 가장 상위에 위치하는 서버로, 도메인 이름을 IP 주소로 변환하는 과정에서 첫 번째로 호출되는 서버다. 이 서버는 DNS 트리의 최상위에 있는 “루트”에 해당하며, 모든 도메인 이름을 관리하는 DNS 계층의 시작점</p>
  </li>
  <li>
    <p>TLD (Top-Level Domain): 도메인 이름에서 가장 마지막 부분을 의미함.예를 들어, example.com에서 .com이 TLD. 다른 예로는 .org, .net, .edu 같은 것들이 있음</p>
  </li>
  <li>
    <p>Authoritative: “권한이 있는”이라는 뜻이다. 즉, 특정 도메인에 대한 정보(예: 해당 도메인과 연결된 IP 주소 등)를 관리하고, 그것에 대한 최종적인 답을 제공할 수 있는 권한을 가진 DNS 서버를 의미함.</p>
  </li>
</ul>

<hr />

<h3 id="local-dns-name-servers">Local DNS name servers</h3>
<p>임의로 생성하여 쓸 수 있는 서버</p>

<p>로컬 DNS 서버는 계층 구조에 포함되지는 않지만, DNS 요청을 처음 처리하는 중요한 역할을 함</p>

<p>ISP, 기업, 학교 등에 기본적으로 존재하며 “기본 네임 서버(Default Name Server)”라고도 불림.</p>

<h3 id="dns-name-resolution-iterated-query">DNS name resolution: iterated query</h3>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/472d9e84-77ef-4635-9fdc-2ee002d0d897/image.png" alt="" /></p>

<p><strong>iterated query</strong> 방식은 특정 도메인에 대한 IP주소를 찾을 때 순차적으로 DNS 서버에 접근하는 방식이 아니라 각개의 DNS 서버에 도메인에 대한 정보를 요청하고 응답받는 형식으로, 원하는 데이터를 얻을 때 까지 개별적으로 DNS 서버에 접근하는 형태를 띤다.</p>

<p>장점? - 속도가 빠르다. 
단점 - 알고리즘이 제대로 구현되지 않았을 때, 매우 복잡해진다.</p>

<h3 id="dns-name-resolution-recursive-query">DNS name resolution: recursive query</h3>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/1b1fdd4f-c183-403a-adfa-ada40d46ccc4/image.png" alt="" /></p>

<p>이 방식은 질의를 보낸 클라이언트 대신, 로컬 DNS 서버가 전체 질의 과정을 처리하는 방식이다. 즉, 서버가 최종 IP 주소를 찾기 위해 필요한 모든 단계를 대신 처리하고, 결과만 클라이언트에게 반환하는 방식이다.</p>

<p>예시에서는 컴퓨터 -&gt; local dns -&gt; root dns -&gt; tld dns -&gt; umass 
이후 역순진행</p>

<p>장점? - 신뢰성이 높은 root dns 
단점? - 모든 사람이 root 서버에 접속하면 연산의 양의 증가하여
더많은 서버나 연산능력이 필요하다.</p>

<h3 id="dns-records">DNS records</h3>

<p>DNS는 리소스 레코드(Resource Record, RR)를 저장하는 분산형 데이터베이스이다. 각 리소스 레코드는 다음과 같은 형식으로 저장된다.</p>
<blockquote>
  <p>(name, value, type, ttl)</p>
</blockquote>

<ul>
  <li>
    <p>name: 호스트 이름(예: 웹사이트 주소나 도메인 이름)</p>
  </li>
  <li>
    <p>value: 해당 호스트의 값(예: IP 주소 또는 다른 서버의 호스트 이름)</p>
  </li>
  <li>
    <p>type: 레코드 유형 (예: A, NS 등)</p>
  </li>
  <li>
    <p>ttl: 시간(Time to Live)으로, 이 값이 만료되기 전에 레코드를 얼마나 캐시할 수 있을지 나타내는 값</p>
  </li>
</ul>

<p><strong>기억!</strong></p>

<ul>
  <li>type = A
    <ul>
      <li>name: 호스트 이름</li>
      <li>value: 해당 호스트의 IP 주소 (예: 192.168.0.1)</li>
    </ul>
  </li>
  <li>type = NS
    <ul>
      <li>name: 도메인 이름 (예: foo.com)</li>
      <li>value: 해당 도메인의 권한을 가진 DNS서버의 호스트 이름 (예: ns1.foo.com)</li>
    </ul>
  </li>
</ul>

<h3 id="inserting-records-into-dns">Inserting records into DNS</h3>

<p><strong>“Network Utopia”</strong> 라는 스타트업이 DNS에 레코드를 삽입하는 과정</p>

<ol>
  <li>도메인 이름 등록</li>
</ol>

<p>networkuptopia.com 도메인을 등록하려고 DNS 등록기관(예: Network Solutions)에 신청을 할려고 한다.</p>

<p>이때 회사는 networkuptopia.com이라는 도메인 이름을 선택하고, 이 이름이 사용 가능한지 확인해야 하며, 사용 가능하다면 등록을 진행할 수 있음</p>

<ol>
  <li>authoritative DNS 서버 정보 제공:</li>
</ol>

<p>도메인 이름을 등록하려면, 도메인 관리용 DNS 서버의 이름과 IP 주소를 제공해야 한다.</p>

<p>이 정보는 도메인 이름 등록과 동시에 TLD 서버에 등록됨</p>

<ol>
  <li>등록기관이 TLD 서버에 레코드 추가</li>
</ol>

<p>등록기관은 .com TLD 서버에 두 가지 레코드를 추가한다.</p>

<ul>
  <li>NS 레코드: networkutopia.com 도메인에 대한 <strong>authoritative DNS 서버</strong>로 dns1.networkuptopia.com을 지정하는 레코드.</li>
</ul>

<p>(networkutopia.com, dns1.networkuptopia.com, NS)</p>

<ul>
  <li>A 레코드: dns1.networkuptopia.com의 IP 주소는 212.212.212.1로 지정하는 레코드.</li>
</ul>

<p>(dns1.networkuptopia.com, 212.212.212.1, A)</p>

<p>이렇게 두 레코드가 TLD 서버에 추가되면, 해당 도메인에 대한 요청은 dns1.networkuptopia.com DNS서버로 향하게 된다.</p>

<ol>
  <li>자신의 DNS 서버 설정:</li>
</ol>

<p>dns1.networkuptopia.com이라는 DNS서버를 자체적으로 설정하는데, 이 네임서버의 IP 주소는 212.212.212.1이야. 이 서버는 이제 networkuptopia.com 도메인에 대한 DNS 요청을 처리하게 된다.</p>

<ol>
  <li>해당 서버에서 필요한 DNS 레코드를 추가해야 한다.</li>
</ol>

<p>A 레코드: www.networkuptopia.com에 대한 IP 주소를 설정.</p>

<p>MX 레코드: networkuptopia.com에 대한 이메일 서버를 설정.</p>

<p><strong>즉 이를 통해 전체적인 흐름을 정리해보자면</strong></p>

<p>유토피아 회사는 등록기관을 통해 사용 가능한 도메인 이름을 찾아서 이를 등록하면, 등록기관에서  그 도메인에 대한 authoritative DNS 서버 정보(dns1.networkuptopia.com , 212.212.212.1)를 TLD 서버에 등록해준다. 이때 A 레코드, NS 레코드를 등록하면 TLD 서버에 추가되고, 해당 도메인(networkutopia.com)에 대한 요청은 authoritative DNS 서버 주소(dns1.networkuptopia.com)로 향하게 된다. 그러고나서 회사는 authoritative DNS 서버에서 A레코드 및 MX 레코드를 설정하여 최종적으로 본인 자사 홈페이지와 연결할 수 있게 설정한다.</p>

<p>클라이언트 입장에서 networkutopia.com 주소를 입력하면 <code class="language-plaintext highlighter-rouge">.com</code> TLD 서버에서 이에 해당하는 도메인을 찾고, 그 도메인의 실제 authoritative DNS 서버 주소로 연결해준다. 이후 authoritative DNS 서버에 설정된 실제 주소를 통해 홈페이지에 접속할 수 있게 된다.</p>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Network" /><category term="Network" /><summary type="html"><![CDATA[Email Email의 세가지 구성요소]]></summary></entry><entry><title type="html">「 Network 」 4주 2차시, Application Layer - HTTP (1)</title><link href="http://localhost:4000/network/ComputerNetwork/" rel="alternate" type="text/html" title="「 Network 」 4주 2차시, Application Layer - HTTP (1)" /><published>2025-03-31T03:00:00+09:00</published><updated>2025-03-31T03:00:00+09:00</updated><id>http://localhost:4000/network/ComputerNetwork</id><content type="html" xml:base="http://localhost:4000/network/ComputerNetwork/"><![CDATA[<h3 id="web--http">WEB &amp; HTTP</h3>
<ul>
  <li>웹 페이지는 객체(objects)로 구성되어 있다.
<!--more-->
    <ul>
      <li>이 객체의 종류는 HTML 파일, JPEG 이미지, Java 애플릿, 오디오 파일 등이 있다.</li>
    </ul>
  </li>
  <li>각 객체는 URL을 통해 접근 가능함. 예를 들어:
    <ul>
      <li>www.someschool.edu/someDept/pic.gif 와 같은 형태</li>
    </ul>
  </li>
</ul>

<p>host name: www.someschool.edu</p>

<p>path name: /someDept/pic.gif</p>

<p>이러한 형태를 <strong>URL</strong>이라 칭한다. host는 웹사이트의 도메인 이름이며, path는 웹 페이지에서 찾는 객체의 경로를 뜻함</p>

<ul>
  <li>HTTP는 애플리케이션 레이어에서 동작하지만, 실제로 데이터를 전송할 때는 전송 계층(TCP/IP)을 사용한다.</li>
</ul>

<h3 id="http-overview">HTTP Overview</h3>

<ul>
  <li>
    <p>HTTP는 하이퍼텍스트 전송 프로토콜으로 <strong>웹에서 데이터를 주고받는 규약</strong> (프로토콜)이다.</p>
  </li>
  <li>
    <p>Web’s application layer protocol</p>
    <ul>
      <li>HTTP는 OSI 모델의 <strong>애플리케이션 계층에서 동작</strong>하는 프로토콜로, 웹에서 데이터를 주고받을 때 사용되는 규칙을 정의해.</li>
    </ul>
  </li>
</ul>

<p>HTTP는 클라이언트/서버 모델을 기반으로 작동한다.</p>

<h3 id="tcp와-http의-상호작용">TCP와 HTTP의 상호작용</h3>

<p>HTTP는 TCP를 사용해서 데이터를 주고받는다. TCP는 전송 계층에서 신뢰성 있는 연결을 제공하는 프로토콜</p>

<ul>
  <li>client initiates TCP connection (creates socket) to server, port 80:</li>
</ul>

<p>클라이언트는 TCP 연결을 시작한다. 즉, 클라이언트(브라우저)는 서버와 연결을 만들기 위해 소켓을 생성하고, 서버의 80번 포트에 연결을 시도함 80번 포트는 HTTP 통신에서 기본적으로 사용되는 포트</p>

<ul>
  <li>server accepts TCP connection from client:</li>
</ul>

<p>서버는 클라이언트의 TCP 연결 요청을 수락 즉, 서버는 클라이언트가 보낸 연결 요청을 받아들이고, 두 시스템 간에 안정적인 연결이 성립된다.</p>

<ul>
  <li>HTTP messages (application-layer protocol messages) exchanged between browser (HTTP client) and Web server (HTTP server):</li>
</ul>

<p>연결이 성립되면, HTTP 메시지(애플리케이션 계층에서의 메시지)가 <strong>클라이언트(브라우저)</strong>와 <strong>서버(웹 서버)</strong> 간에 교환돼. 클라이언트가 HTTP 요청을 보내고, 서버는 이에 대한 HTTP 응답을 보내는 방식임</p>

<ul>
  <li>TCP connection closed:</li>
</ul>

<p>HTTP 메시지가 주고받은 후, TCP 연결은 종료된다. 데이터를 모두 교환한 후, 연결을 닫아 네트워크 자원을 반환하는 과정이다.</p>

<p>또한 HTTP는 <strong>Stateless</strong>한 특성을 지니고 있는데,
 이는 매번 <strong>새로운 요청을 독립적으로 처리하고, 과거의 상태를 기억하지 않는다.</strong> 이 덕분에 구현이 간단하지만, 상태를 관리하려면 추가적인 기술이 필요하다.</p>

<h3 id="http-connections-two-types">HTTP connections: two types</h3>

<ol>
  <li>Non-persistent HTTP</li>
</ol>

<p>기본적으로 한 번의 HTTP 요청마다 새로운 TCP 연결을 열고, 요청을 처리한 후에는 연결을 닫는 방식이다.</p>

<ol>
  <li>Persistent HTTP</li>
</ol>

<p>한 번의 TCP 연결을 통해 여러 개의 객체를 다운로드할 수 있디. 연결이 닫히지 않고 계속 열려 있다가 더이상 연결이 필요 없을 때 닫히는 방식이다.</p>

<h3 id="non-persistent-http-example">Non-persistent HTTP: example</h3>

<p>우리의 컴퓨터와 학교 서버의 에시를 Non-persistent 예시를 들어보자</p>

<p>우선 유저는 아래의 URL을 입력한다.
User enters URL: www.someSchool.edu/someDepartment/home.index</p>

<ol>
  <li>
    <p><strong>클라이언트가</strong> TCP 연결을 시작한다. 매번 새로운 요청을 할 때마다 클라이언트는 새로운 TCP 연결을 연다.</p>
  </li>
  <li>
    <p>서버는 80번 포트에서 TCP 연결을 기다리다가 클라이언트의 연결 요청을 수락하고 연결을 완료한다.</p>
  </li>
  <li>
    <p>클라이언트는 HTTP 요청 메시지를 보내고, 그 안에 요청하는 URL인 someDepartment/home.index를 포함시킨다. 이 메시지는 하나의 객체만 요청한다.</p>
  </li>
  <li>
    <p>서버는 클라이언트의 요청을 받고, 요청된 someDepartment/home.index 객체를 응답 메시지에 포함시켜 클라이언트에게 전송한다.</p>
  </li>
  <li>
    <p>서버는 클라이언트가 요청한 HTML 파일을 보낸 후 TCP 연결을 닫음.
이후 JPEG 이미지 요청이 들어올 때마다 새로운 TCP 연결을 열고 닫아야 함.</p>
  </li>
  <li>
    <p><strong>클라이언트(웹 브라우저)</strong>가 서버로부터 HTML 파일을 받는다.
이 HTML을 화면에 표시하고, HTML 내부에 포함된 이미지(jpeg 10개)를 찾는다.</p>
  </li>
</ol>

<p>그러나 여기서 jpeg 파일 10개를 전부 찾으려면 Non-persistent HTTP에서는 각 객체(10개의 이미지)마다 새로운 TCP 연결을 열어야 한다.</p>

<h3 id="rtt-round-trip-time">RTT (Round-Trip Time)</h3>

<p>클라이언트가 요청을(request) 하고 응답(response)을 받는 
일련의 시간 ( 클라이언트 → 서버 → 클라이언트 왕복 시간 )</p>

<p>여러 개의 객체를 요구할 경우 RTT 계산 시간?</p>

<ul>
  <li>
    <p>HTML 파일: 2 RTT + 전송 시간</p>
  </li>
  <li>
    <p>각 이미지: (2 RTT + 전송 시간) × 10개</p>
  </li>
  <li>
    <p>총 시간 = (2 RTT + 전송 시간) × 11</p>
  </li>
</ul>

<h3 id="non-persistent-http-issues">Non-persistent HTTP issues</h3>

<ul>
  <li>
    <p>각 객체(파일)마다 TCP 연결을 새로 열고 닫아야 하기 떄문에 객체가 2 RTT 발생</p>
  </li>
  <li>
    <p>각 TCP 연결을 열고 닫을 때마다 OS의 리소스를 사용해야 함. 이는 연결을 설정하고 관리하는 과정에서 CPU, 메모리 사용량 증가.</p>
  </li>
  <li>
    <p>이를 해결하기 위한 방법으로 Persistent HTTP가 등장함</p>
  </li>
</ul>

<h3 id="persistent-http-http11">Persistent HTTP (HTTP1.1)</h3>

<ul>
  <li>
    <p>서버가 응답을 보낸 후에도 TCP 연결을 유지한다</p>
  </li>
  <li>
    <p>같은 클라이언트와 서버 간의 추가 요청/응답이 열린 연결에서 처리됨</p>
  </li>
  <li>
    <p>클라이언트는 HTML을 분석하는 즉시 추가 요청을 보냄</p>
  </li>
  <li>
    <p><strong>최소한 1 RTT로 여러 개의 객체 다운로드 가능 (응답 시간 단축)</strong></p>
  </li>
</ul>

<h3 id="maintaining-userserver-state-cookies-쿠키로-상태-유지하기">Maintaining User/Server State: Cookies (쿠키로 상태 유지하기)</h3>

<p>HTTP는 기본적으로 <strong>stateless</strong>한 프로토콜이다.</p>

<p>즉, 각 요청은 독립적이고, 서버는 이전 요청 정보를 기억하지 않음.</p>

<p>이 때문에, 사용자 상태를 유지하려면 별도의 방법이 필요한데, 그중 가장 대표적인 방법이 <strong>쿠키(Cookie)</strong> 다.</p>

<h3 id="cookies">Cookies?</h3>
<p>쿠키는 클라이언트(브라우저)에 저장되는 작은 데이터 조각으로, HTTP가 무상태라는 한계를 보완함</p>

<p><strong>동작 방식을 살펴보면</strong></p>
<ul>
  <li>
    <p>클라이언트가 서버에 요청을 보냄.</p>
  </li>
  <li>
    <p>서버는 응답과 함께 Set-Cookie 헤더를 추가하여 쿠키를 클라이언트에 저장하도록 요청.</p>
  </li>
  <li>
    <p>이후 클라이언트가 서버에 요청할 때마다 해당 쿠키를 자동으로 전송하여 사용자 상태 유지 가능</p>
  </li>
</ul>

<p>예를 들어 내가 네이버에 접속하면 서버는 클라이언트에 대한 정보를 저장해놓고,
다음 접속때는 특정 오브젝트만 로드하기 때문에 속도가 증가하는 효과를 볼 수 있다.</p>

<p>하지만 쿠키는 보안 이슈가 존재하기 때문에 이를 잘 보완해야 한다.</p>

<h3 id="what-cookies-can-be-used-for">What cookies can be used for</h3>
<ul>
  <li>authorization (인증)</li>
  <li>shopping carts (장바구니)</li>
  <li>recommendations (광고, 추천시스템)</li>
  <li>user session state (Web e-mail) (이메일 세션 유지)</li>
</ul>

<h3 id="cookies-and-privacy">cookies and privacy</h3>
<ul>
  <li>
    <p>쿠키는 웹사이트가 사용자의 활동을 학습할 수 있도록 허용한다.</p>
  </li>
  <li>
    <p>서드파티 영구 쿠키(추적 쿠키)는 동일한 쿠키 값을 사용하여 여러 웹사이트에서 사용자의 신원을 추적할 수 있다. 즉 개인정보에 유의해야 한다.</p>
  </li>
</ul>

<h3 id="web-caches-proxy-servers">Web caches (proxy servers)</h3>

<p>프록시 서버는 클라이언트와 서버 사이에서 중개 역할을 하는 서버로,  클라이언트가 서버에 직접 요청하는 대신, 프록시 서버가 대신 요청을 처리해주고, 그 결과를 클라이언트에게 전달하는 방식이다.</p>

<p>프록시 서버의 기능 중 하나인 <strong>웹 캐시</strong>는 자주 요청되는 웹 콘텐츠(HTML 파일, 이미지 등)를 <strong>캐시(임시 저장)</strong>해서, 반복적으로 요청이 오면 원본 서버에 요청하지 않고 바로 응답을 줄 수 있다.</p>

<ul>
  <li>브라우저가 요청을 직접 원본 서버로 보내지 않고, 먼저 웹 캐시(프록시 서버)를 거치도록 설정한다.
    <ul>
      <li>예를 들어 프록시 서버가 요청을 처리할 수 있으면 바로 응답, 없으면 원본 서버에서 가져와 저장한 후 응답</li>
    </ul>
  </li>
  <li>브라우저가 모든 HTTP 요청을 웹 캐시(프록시 서버)로 보낸다
    <ol>
      <li>브라우저가 웹 캐시에 요청을 보냄</li>
      <li>웹 캐시에 해당 객체(파일)가 있는지 확인
        <ul>
          <li>
            <p>만약 캐시에 있으면?
  → 웹 캐시가 즉시 파일을 클라이언트(사용자)에게 반환</p>
          </li>
          <li>
            <p>캐시에 없으면?
  → 웹 캐시가 원본 서버에 요청
  → 받아온 데이터를 캐시에 저장한 후, 사용자에게 전달</p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p>즉 프록시 서버가 있고, 웹 캐시가 있는데 프록시 서버의 개념이 웹 캐시임 잘 파악하자!</p>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Network" /><category term="Network" /><summary type="html"><![CDATA[WEB &amp; HTTP 웹 페이지는 객체(objects)로 구성되어 있다.]]></summary></entry><entry><title type="html">Backend 3-Tier Architecture, Business Logic</title><link href="http://localhost:4000/backend/BackEnd-3tier/" rel="alternate" type="text/html" title="Backend 3-Tier Architecture, Business Logic" /><published>2025-03-29T03:00:00+09:00</published><updated>2025-03-29T03:00:00+09:00</updated><id>http://localhost:4000/backend/BackEnd-3tier</id><content type="html" xml:base="http://localhost:4000/backend/BackEnd-3tier/"><![CDATA[<h3 id="3계층-구조-three-tier-architecture">3계층 구조 (Three-Tier Architecture)</h3>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/0c708033-f7bd-48cc-bba3-517ea5806f34/image.png" alt="" /></p>

<p>백엔드의 내부 로직을 3계층으로 분리하여 각각의 역할을 담당하는 아키텍처로 유지보수가 쉽고, 확장성이 좋다는 장점이 있다.
<!--more--></p>

<p><strong>1. 프레젠테이션(Presentation layer)</strong></p>
<ul>
  <li>사용자의 요청을 받고, 결과를 사용자에게 반환하는 역할</li>
  <li>주로 <strong>컨트롤러(Controller)</strong> 가 이 계층에 해당</li>
  <li>즉, 컨트롤러는 사용자와 백엔드 사이의 다리 역할</li>
</ul>

<p><strong>2. 로직(Logic later)</strong></p>
<ul>
  <li>핵심적인 비즈니스 로직을 담당하는 계층</li>
  <li>데이터를 검증하고, 가공하고, 여러 개의 요청을 조합해서 처리</li>
  <li>컨트롤러와 데이터 계층(리포지토리) 사이에서 중간 다리 역할</li>
</ul>

<p>흐름:</p>

<ul>
  <li>
    <p>컨트롤러에서 받은 요청을 분석하고 필요한 데이터를 가져옴</p>
  </li>
  <li>
    <p>가져온 데이터로 필요한 로직을 수행</p>
  </li>
  <li>
    <p>처리된 결과를 컨트롤러로 반환</p>
  </li>
</ul>

<p>쉽게 말하면, <strong>데이터를 어떻게 처리할지 결정하는 곳</strong></p>

<p><strong>3. 데이터 계층 (Data Layer)</strong></p>
<ul>
  <li>데이터베이스와 직접 소통하는 역할</li>
  <li>데이터를 저장, 조회, 수정, 삭제 (CRUD)</li>
  <li>서비스 계층에서 요청한 데이터를 제공</li>
</ul>

<hr />

<h3 id="business-logic">Business Logic?</h3>
<p>애플리케이션에서 “실제 기능”을 수행하는 핵심 로직을 의미한다.
즉, 단순한 데이터 전달이 아니라, <strong>“어떤 규칙이나 절차를 적용해서 데이터를 가공하고 처리하는 과정”</strong></p>

<p><strong>비즈니스 로직이 필요한 이유?</strong></p>

<p>웹 애플리케이션은 단순히 데이터를 주고받는 게 아니라, “사용자 요구에 맞는 특정한 작업”을 수행해야 함.</p>

<p>예를 들어, 회원가입을 할 때 단순히 “이름과 이메일을 저장하는 것”이 아니라, 아래와 같은 검증 과정이 필요할 수 있음.</p>

<ol>
  <li>
    <p>이메일이 이미 가입된 사용자라면? → “이미 존재하는 이메일입니다.” 오류 반환</p>
  </li>
  <li>
    <p>비밀번호가 너무 짧다면? → “비밀번호는 최소 8자 이상이어야 합니다.”</p>
  </li>
  <li>
    <p>회원가입 후 환영 이메일 보내기</p>
  </li>
</ol>

<p>이런 작업들은 단순한 데이터 저장이 아니라, <strong>“회원가입이라는 비즈니스 규칙”</strong>을 따르는 것</p>

<p>-&gt; 이러한 모든 작업이 “비즈니스 로직”에 해당됨</p>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Backend" /><category term="Backend" /><summary type="html"><![CDATA[3계층 구조 (Three-Tier Architecture) 백엔드의 내부 로직을 3계층으로 분리하여 각각의 역할을 담당하는 아키텍처로 유지보수가 쉽고, 확장성이 좋다는 장점이 있다.]]></summary></entry><entry><title type="html">Getter &amp;amp; Setter</title><link href="http://localhost:4000/java/Java-getter-setter/" rel="alternate" type="text/html" title="Getter &amp;amp; Setter" /><published>2025-03-29T02:00:00+09:00</published><updated>2025-03-29T02:00:00+09:00</updated><id>http://localhost:4000/java/Java-getter-setter</id><content type="html" xml:base="http://localhost:4000/java/Java-getter-setter/"><![CDATA[<h4 id="getter--setter">Getter &amp; Setter?</h4>

<p>클래스 내부의 private 필드에 접근하거나 값을 설정하는 방법을 제공하는 메서드들이다.</p>

<!--more-->
<p>Getter: 필드의 값을 반환하는 메서드</p>

<p>Setter: 필드의 값을 설정하는 메서드</p>

<h4 id="왜-필요한가">왜 필요한가?</h4>
<p>자바에서는 private 접근 제어자를 사용해서 클래스의 필드를 외부에서 직접 접근하지 못하도록 막을 수 있는데, Getter와 Setter는 이런 제한을 우회해서 필드에 접근하거나 값을 변경할 수 있게 해주는 역할을 한다.</p>

<h4 id="예시">예시</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Person {

    // 필드는 private으로 설정 (외부에서 직접 접근 불가)
    private String name;
    private int age;

    // Getter: name 필드의 값을 반환
    public String getName() {
        return name;
    }

    // Setter: name 필드에 값을 설정
    public void setName(String name) {
        this.name = name;
    }

    // Getter: age 필드의 값을 반환
    public int getAge() {
        return age;
    }

    // Setter: age 필드에 값을 설정
    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre></div></div>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Java" /><category term="Java" /><summary type="html"><![CDATA[Getter &amp; Setter? 클래스 내부의 private 필드에 접근하거나 값을 설정하는 방법을 제공하는 메서드들이다.]]></summary></entry><entry><title type="html">「 Network 」 4주 1차시, Application Layer (2)</title><link href="http://localhost:4000/network/Network-05/" rel="alternate" type="text/html" title="「 Network 」 4주 1차시, Application Layer (2)" /><published>2025-03-25T01:00:00+09:00</published><updated>2025-03-25T01:00:00+09:00</updated><id>http://localhost:4000/network/Network-05</id><content type="html" xml:base="http://localhost:4000/network/Network-05/"><![CDATA[<h2 id="an-application-layer-protocol-defines">An application-layer protocol defines</h2>
<p>애플리케이션 계층 프로토콜은 네트워크를 통해 <code class="language-plaintext highlighter-rouge">프로세스 간의 통신 방식</code>을 규정하는 규칙들을 말한다.</p>

<!--more-->

<p>애플리케이션 계층 프로토콜이 정의하는 주요 요소들은 아래와 같다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Message syntax</code>
    <ul>
      <li>메시지 형식을 정의하는데, 이 형식 안에서 프레임의 구성 요소인 필드를 어떻게 배치하고, 각 필드가 무엇을 의미하는지 규정하는 것</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Message semantics</code>
    <ul>
      <li>메시지 필드에 포함된 0과 1로 이루어진 데이터를 해석하는 것</li>
    </ul>
  </li>
</ul>

<h2 id="what-transport-service-does-an-app-need">What transport service does an app need</h2>
<p>애플리케이션 계층에서 필요한 중요한 요소들</p>

<ol>
  <li>Data Integrity (데이터 무결성)
    <ul>
      <li>예를 들어 데이터를 받을 때 그 데이터에 대한 <code class="language-plaintext highlighter-rouge">신뢰성의 정도</code></li>
    </ul>
  </li>
  <li>timing
    <ul>
      <li>쉽게 말해 Delay</li>
      <li>얼마나 제 시간에 도착하는지, 짧은 수록 좋은 값</li>
    </ul>
  </li>
  <li>throughput(처리량)
    <ul>
      <li>1초당 보낼 수 있는 데이터의 총량, 클 수록 좋은 값</li>
    </ul>
  </li>
</ol>

<p>여기서 한 가지 알아둬야 할 점은
(중요) <code class="language-plaintext highlighter-rouge">Trade Off</code> : 어떠한 값의 성능을 올리기 위해선 다른 하나의 값의 성능을 낮춰야한다. 이는 네트워크적 측면에서 절대적인 개념이다.</p>

<ol>
  <li>security(보안)
    <ul>
      <li>encryption - 암호화</li>
      <li>data integrity - 데이터 무결성</li>
    </ul>
  </li>
</ol>

<h2 id="transport-service-requirements-common-apps">Transport service requirements: common apps</h2>
<p>전송 서비스의 요구 사항을 일반적인 app들을 예로 들어보면 아래와 같다.</p>

<p>일상생활에서 마주할 수 있는 app들을 기준으로 데이터 손실, 처리량, 시간 민감도에 대한 차이를 보여준다.</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/b8eec8a0-6efe-43d1-9964-9c7adeaec6ec/image.png" alt="" /></p>

<h2 id="internet-transport-protocols-services">Internet transport protocols services</h2>

<ol>
  <li>TCP service
TCP 서비스는 기본적으로 정확성이 높으며, 시간이 오래걸림. 이러한 이유에는 <code class="language-plaintext highlighter-rouge">복잡한 구조</code>가 있다.</li>
</ol>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">reliable transport</code></strong> : 정확성이 높으나 속도가 낮다. 또한 아래의 기능들이 전부 작동되어야 정확성을 얻을 수 있다.
    <ul>
      <li>flow control(흐름 제어) : 즉 너무 많은 데이터를 한 번에 보내지 않도록 조절, 받는 쪽이 처리할 수 있는 속도로만 데이터를 전송한다.</li>
      <li>congestion control (혼잡 제어) : congenstion은 교통 체증을 뜻하는데, congenstion이 발생했을 떄 어떤 경로, 뭐부터 처리할건지
정의하고 처리하는 역할을 한다.</li>
    </ul>
  </li>
  <li>
    <p>does not provide (제공하지 않는 것들) : 대표적으로 security(보안)이 있다.</p>
  </li>
  <li><strong>connection-oriented (연결 지향적)</strong> : TCP는 연결 지향적 프로토콜이기 때문에, 데이터를 전송하기 전에 클라이언트와 서버가 서로 연결을 설정해야 한다.
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">hand shaking</code></strong> :  가상의 송신자와 수신자가 존재하는 통로(connection)를 만들어내는 것
  즉 hand shaking 과정을 통해 서로간의 연결을 할 수 있다.</li>
    </ul>
  </li>
</ul>

<ol>
  <li>UDP service
UDP 서비스는 기본적으로 시간이 오래 걸리지 않으며, 정확성이 낮다. 이러한 이유로는 단순한 구조때문임</li>
</ol>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">unreliable data transfer</code></strong> : 데이터 전송의 신뢰성이 보장되지 않는다는 뜻이야.</p>
  </li>
  <li>
    <p>does not provide (제공하지 않는 것들 ): connection setup, security</p>
    <ul>
      <li>일방적으로 송신자가 데이터를 뿌리는 것이기 때문에 connection less</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Tcp와 Udp 는 같은 통로를 쓰기 때문에 오류는 같이 발생함
그런데 왜 TCP는 정확성을 보장하나?
-&gt; 데이터를 받았을 때 ACK(acknowledge) 를 체크하고,
제대로 받지 못하면 발신자가 이에 대한 ACK를 받게 됨
그러면 발신자가 다시 데이터를 보내게 됨
이는 데이터가 제대로 받았는지 확인될 때까지 재전송하기 떄문임
반대로 UDP 는 ACK를 보내지 않기 때문에 데이터를 빠르게 
보낼 수 있는 것임</p>
</blockquote>

<h2 id="securing-tcp">Securing TCP</h2>

<ul>
  <li>Vanilla TCP &amp; UDP sockets
    <ul>
      <li>암호화되지 않아서 보안이 취약함.</li>
    </ul>
  </li>
  <li>Transport Layer Security (TLS)
    <ul>
      <li>데이터를 암호화 함으로서, data integrity를 보장</li>
      <li><code class="language-plaintext highlighter-rouge">end-point authentication</code> : 엔드 포인트에서 클라이언트 또는 서버가 각 상대방이 안전한 상태인지 <code class="language-plaintext highlighter-rouge">인증</code>을 통해 신뢰성을 확인</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">TLS implemented in application layer </code>
    <ul>
      <li>TLS는 어플리케이션 계층에서 구현된다</li>
    </ul>
  </li>
</ul>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Network" /><category term="Network" /><summary type="html"><![CDATA[An application-layer protocol defines 애플리케이션 계층 프로토콜은 네트워크를 통해 프로세스 간의 통신 방식을 규정하는 규칙들을 말한다.]]></summary></entry><entry><title type="html">「 Network 」 3주 2차시, Application Layer (1)</title><link href="http://localhost:4000/network/ComputerNetwork_04/" rel="alternate" type="text/html" title="「 Network 」 3주 2차시, Application Layer (1)" /><published>2025-03-24T01:00:00+09:00</published><updated>2025-03-24T01:00:00+09:00</updated><id>http://localhost:4000/network/ComputerNetwork_04</id><content type="html" xml:base="http://localhost:4000/network/ComputerNetwork_04/"><![CDATA[<p>Application Layer 에는 다음과 같은 예시가 있다.
<!--more--></p>

<ul>
  <li>social networking</li>
  <li>Web</li>
  <li>text messaging</li>
  <li>e-mail</li>
  <li>multi-user network games</li>
  <li>streaming stored video (YouTube, Hulu, Netflix)</li>
  <li>P2P file sharing</li>
</ul>

<h2 id="creating-a-network-app">Creating a network app</h2>

<ol>
  <li>Application은 End System에서 실행된다.</li>
  <li>이는 네트워크를 통해 데이터를 주고받음</li>
  <li>라우터 같은 네트워크 장치(코어 장비)에는 애플리케이션을 설치하지 않음
    <ul>
      <li>네트워크 장치는 데이터를 “전달”할 뿐, 애플리케이션을 실행하지 않음!</li>
      <li>즉, 우리는 라우터를 프로그래밍할 필요 없이, 사용자 장치에서 애플리케이션을 개발하면 됨</li>
    </ul>
  </li>
</ol>

<h2 id="client-server-paradigm">Client-server paradigm</h2>
<p>클라이언트-서버 모델은 <strong>클라이언트(Client)</strong> 가 <strong>서버(Server)</strong> 에 요청(Request)을 보내고, 서버가 해당 요청을 처리한 후 <strong>응답(Response)</strong> 을 보내주는 구조</p>

<ol>
  <li>서버(Server)의 특징
    <ul>
      <li>항상 켜져 있는(Always-on) 호스트</li>
    </ul>
  </li>
</ol>

<ul>
  <li>고정된(IP Address) 주소 사용
    <ul>
      <li>클라이언트가 언제든지 서버에 접속할 수 있도록 영구적인 IP 주소를 가짐.</li>
    </ul>
  </li>
  <li>대규모 서비스를 위해 데이터센터에 위치
    <ul>
      <li>예를 들어, 넷플릭스의 경우 온갖 영화(데이터)가 데이터센터에 들어가있다고 생각하면 됨</li>
    </ul>
  </li>
</ul>

<ol>
  <li>클라이언트(Client)의 특징
    <ul>
      <li>서버에 접속하여 요청을 보냄</li>
    </ul>
  </li>
</ol>

<ul>
  <li>일시적으로 연결됨(Intermittently connected)
    <ul>
      <li>필요할 때만 서버에 접속하고, 평소에는 네트워크 연결이 없어도 됨.</li>
    </ul>
  </li>
  <li>동적인(Dynamic) IP 주소 사용
    <ul>
      <li>IP address는 한정적이기 때문</li>
    </ul>
  </li>
  <li>클라이언트끼리는 직접 통신하지 않음
    <ul>
      <li>일반적으로 서버를 거쳐야 클라이언트 간 통신이 가능함.</li>
    </ul>
  </li>
</ul>

<h2 id="p2p-peer-to-peer-architecture">P2P (Peer-to-Peer) Architecture</h2>

<p><code class="language-plaintext highlighter-rouge">엔드 유저(클라이언트)</code> 장치들 간 직접 통신하는 구조</p>

<ul>
  <li>서버 없이(peer끼리) 직접 통신</li>
  <li>각 피어(Peer)가 동시에 클라이언트 &amp; 서버 역할 수행</li>
  <li><code class="language-plaintext highlighter-rouge">Self Scalability</code>
    <ul>
      <li>새로운 피어(사용자)가 생기면 서비스 요청자 + 제공자 역할을 동시에 함</li>
      <li>피어가 많아질수록 네트워크 처리량(Throughput)도 증가</li>
      <li>서버 없이도 자연스럽게 확장됨</li>
      <li>즉, <code class="language-plaintext highlighter-rouge">네트워크들의 연결성과 범위를 스스로 줄였다 늘렸다 하는 것을 의미</code></li>
    </ul>
  </li>
  <li>Peer는 네트워크에 일시적으로 연결되고, IP 주소가 자주 변경됨
    <ul>
      <li>관리 복잡 (중앙 관리 서버가 없어서 어려움)</li>
    </ul>
  </li>
</ul>

<h2 id="processes-communicating">Processes Communicating</h2>

<ul>
  <li>프로세스(Process)란? : 운영 중인 프로그램 (CPU에서 실행 중인 프로그램)
    <ul>
      <li>하나의 컴퓨터에는 여러개의 프로세스가 동작가능하다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">프로세스 간 통신 (Inter-Process Communication)</code>
    <ul>
      <li>하나의 호스트에서 OS를 통과해서 앱들끼리 통신을 할 수 있는 것을 의미한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">서로 다른 호스트</code>에 있는 프로세스들은 <strong>메시지</strong> 를 교환하여 통신한다. 
그거를 패킷이라 표현하는데 7계층이라 메세지라고 표현한다.</li>
</ul>

<h2 id="sockets">Sockets</h2>
<p><code class="language-plaintext highlighter-rouge">소켓(Socket)</code>은 네트워크 통신에서 프로세스가 메시지를 보내고 받는 창구를 의미한다.</p>

<p>이는 문에 비유할 수 있는데,</p>
<ul>
  <li>보내는 프로세스는 메시지를 소켓을 통해 “문 밖으로” 보낸다.</li>
  <li>받는 프로세스는 “문 안”에 있는 소켓을 통해 메시지를 받는다.</li>
</ul>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/70cb6cc4-1388-405e-8807-4cbf5b490eb8/image.png" alt="" /></p>

<p>App을 벗어나는 통로를 socket이라 칭한다.</p>

<h2 id="addressing-processes">Addressing Processes</h2>

<p>프로세스가 메시지를 받으려면, 그 프로세스를 식별할 수 있는 고유한 아이디가 필요하다. 이를 위해서 IP 주소와 포트 번호가 사용된다.</p>

<ul>
  <li>IP 주소와 프로세스의 관계
    <ul>
      <li>
        <p>호스트 장치는 고유한 32비트 IP 주소를 가짐.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">하지만, IP 주소만으로는 특정 프로세스를 식별할 수 없다.</code> 왜냐하면 하나의 호스트에서 여러 프로세스가 동시에 실행되기 때문임</p>
      </li>
    </ul>
  </li>
</ul>

<p>즉 프로세스를 식별하기 위한 주소는 <code class="language-plaintext highlighter-rouge">IP 주소</code>와 <code class="language-plaintext highlighter-rouge">포트 번호</code> 두 가지를 포함한다.</p>

<p>비슷한 경우로 로컬 네트워크 내에서 장치간에서는 <code class="language-plaintext highlighter-rouge">Mac Address</code> 를 통해서 통신을 할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">Mac Address?</code> -  물리적 네트워크 장치(예: 컴퓨터, 스마트폰, 라우터 등)에 할당된 고유한 식별자를 의미한다. 이는 변경할 수 없다.</p>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Network" /><category term="Network" /><summary type="html"><![CDATA[Application Layer 에는 다음과 같은 예시가 있다.]]></summary></entry><entry><title type="html">「 AWS 」 EC2 인스턴스 생성및 Apache로 배포</title><link href="http://localhost:4000/infra/aws/AWS_Server/" rel="alternate" type="text/html" title="「 AWS 」 EC2 인스턴스 생성및 Apache로 배포" /><published>2025-03-18T01:00:00+09:00</published><updated>2025-03-18T01:00:00+09:00</updated><id>http://localhost:4000/infra/aws/AWS_Server</id><content type="html" xml:base="http://localhost:4000/infra/aws/AWS_Server/"><![CDATA[<p>Apache로 웹서버를 구축하고, 배포까지 해보려 했으나 공유기 Admin 설정 문제로 지금까지 미뤄왔던 AWS를 활용한 배포를 해보려한다.</p>

<!--more-->

<p><strong>회원가입</strong>을 통해 AWS 계정을 생성해준다. ( 과정 생략 )</p>

<h3 id="ec2-인스턴스-생성">EC2 인스턴스 생성</h3>

<h4 id="1-좌측-상단-검색창에-ec2를-검색한-후-클릭해준다">1. 좌측 상단 검색창에 <strong>EC2</strong>를 검색한 후 클릭해준다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/3a5ac3df-bfc8-4ede-9d1d-55754d613da4/image.png" alt="" /></p>

<h4 id="2-우측-인스턴스-시작을-눌러준다">2. 우측 인스턴스 시작을 눌러준다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/ec63d5df-9736-4df9-8ed6-7b4437562002/image.png" alt="" /></p>

<h4 id="3-인스턴스명은-내가-알아보기-쉽도록-설정하면-된다">3. 인스턴스명은 내가 알아보기 쉽도록 설정하면 된다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/3180b1ae-f8ac-4cf7-b08b-7f9c2a83c9de/image.png" alt="" /></p>

<h4 id="4-ami-설정은-아래의-형식을-따랐다">4. AMI 설정은 아래의 형식을 따랐다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/034a28fb-c710-4ad5-bcdd-88562ae01111/image.png" alt="" /></p>

<p>나는 아직 잘 모르기 때문에 운영체제는 Ubuntu를 골랐으며, 버전은 <code class="language-plaintext highlighter-rouge">24.04 LTS</code> 와 <code class="language-plaintext highlighter-rouge">22.04 LTS</code>가 있는데, 둘 다 프리 티어 사용이 가능해서 아무래도 안정적인 22.04 버전을 사용했다.</p>

<p>아키텍처는 앞선 이유와 동일하게 잘 모르기 때문에 기본설정인 <code class="language-plaintext highlighter-rouge">64비트(x86)</code> 를 사용했다.</p>

<h4 id="5-인스턴스-유형은-프리-티어가-가능한-t2micro-모델을-사용한다">5. 인스턴스 유형은 프리 티어가 가능한 <code class="language-plaintext highlighter-rouge">t2.micro</code> 모델을 사용한다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/b76420fa-20ee-43de-bf67-6c1b39165d10/image.png" alt="" /></p>

<p><strong>EC2 인스턴스 유형(Instance Type)</strong> 은 CPU, 메모리(RAM), 네트워크 성능 등에 따라 분류된 <strong>서버의 스펙(성능 등급)</strong> 이라고 알면 된다.</p>

<h4 id="6-키페어의-이름은-본인이-식별할-수-있도록-설정한다">6. 키페어의 이름은 본인이 식별할 수 있도록 설정한다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/36151bf1-77db-4fef-bf43-fd813cb4e48f/image.png" alt="" /></p>

<p>RSA의 보안성이 높고 널리 지원되고 있으며, pem키 또한 다양한 운영 체제에서 사용 가능하게 지원되기 때문에 많이 사용한다고 한다.</p>

<p>또한 키페어는 <strong>절대 유출되어서는 안되기 떄문에</strong> 따로 잘 보관하도록 하자.</p>

<h4 id="7-네트워크-설정">7. 네트워크 설정</h4>
<p><img src="https://velog.velcdn.com/images/ghkdehs/post/f817914e-4bc6-4f56-a7e1-dcf86a0d69f2/image.png" alt="" /></p>

<p>SSH(개발 환경 터미널)는 내 IP로 접근할 수 있도록 설정하여 보안을 신경써주는 것이 좋다.</p>

<p>또한 HTTPS 와 HTTP 트래픽을 체크하여 포트를 열어주어 각각 보안과 웹 브라우저 접근을 허용한다.</p>

<h3 id="인스턴스에-ssh로-접속하기">인스턴스에 SSH로 접속하기</h3>

<h4 id="1ssh-키-파일-권한-설정">1.SSH 키 파일 권한 설정</h4>
<p>.pem 파일의 권한을 변경해야 한다. (파일 권한 문제로 접속이 안 될 수 있음)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod 400 /path/to/your/SSH_Key.pem
</code></pre></div></div>

<h4 id="2ec2-인스턴스에-접속하기">2.EC2 인스턴스에 접속하기</h4>
<p>AWS에서 EC2 인스턴스의 공인 IP 주소를 확인하고, 다음 명령어로 접속한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh -i /path/to/your/SSH_Key.pem ec2-user@&lt;EC2_PUBLIC_IP&gt;
</code></pre></div></div>

<p>2번까지 완료하고 나면 서버의 신뢰성을 확인할 수 없다는 메세지가 뜨면서, <strong>“Are you sure you want to continue connecting?”</strong> 이라는 질문이 나올 것이다. 이때는 그냥 yes를 입력해주면 다음에 같은 서버를 접속할때 이와같은 경고문자가 나타나지 않을 것이다.</p>

<p>터미널에서 <strong>시용자이름@EC2공인IP주소</strong> 와 같은 형태로 바뀌었다면 EC2 서버에 제대로 접속이 된 것이다.</p>

<h3 id="ec2-인스턴스에-apahce-web-server-설정">EC2 인스턴스에 Apahce Web Server 설정</h3>

<h4 id="1-apache-설치하기">1. Apache 설치하기</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt install apache2 -y
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sudo apt update</code> : 패키지 목록을 업데이트</p>

<p><code class="language-plaintext highlighter-rouge">sudo apt install apache2 -y</code> : Apache 웹 서버 설치</p>

<h4 id="2-apache-서버-실행하기">2. Apache 서버 실행하기</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo systemctl start apache2
</code></pre></div></div>
<p>위 명령어를 치고, 
<code class="language-plaintext highlighter-rouge">http://IP주소</code> 를 입력하면</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/0576c2dd-57a4-4da6-a211-fe542975245d/image.png" alt="" /></p>

<p>기본 Apache 시작 화면이 나올 것이다.</p>

<h4 id="3-apache-자동-시작-설정">3. Apache 자동 시작 설정</h4>

<p>서버가 재부팅되더라도 Apache가 자동으로 시작되도록 설정한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo systemctl enable apache2
</code></pre></div></div>

<h4 id="4-서버-상태-확인">4. 서버 상태 확인</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo systemctl status apache2 
</code></pre></div></div>
<p>위 명령어를 입력하고</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/26463779-d219-4593-9a14-95d70d92e7ff/image.png" alt="" /></p>

<p>active(running)이 뜨면 정상적으로 실행 중인 것이다.</p>

<h3 id="로컬-apache-파일을-ec2-apahce-폴더로-옮기기">로컬 Apache 파일을 EC2 Apahce 폴더로 옮기기</h3>

<h4 id="1-ec2-인스턴스에-임시로-파일-복사하기">1. EC2 인스턴스에 임시로 파일 복사하기</h4>
<p>나는 Apache 폴더 내의 index.html과 css 파일을 옮기려고 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp -i ~/Desktop/KeyPair/YourKey.pem /path/to/your/local/index.html ubuntu@123.45.67.89:/var/www/html/
scp -i ~/Desktop/KeyPair/YourKey.pem /path/to/your/local/style.css ubuntu@123.45.67.89:/var/www/html/
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">scp</code> : Secure Copy Protocol의 약자로, SSH를 사용하여 <code class="language-plaintext highlighter-rouge">원격 서버</code>와 <code class="language-plaintext highlighter-rouge">로컬 시스템</code> 간에 파일을 안전하게 전송하는 명령어다.</p>

<p><code class="language-plaintext highlighter-rouge">-i</code> :  identity file을 지정하는 옵션으로, SSH 연결 시 사용할 개인 키(private key) 파일을 지정하며, 이 키는 서버에 접속할 때 인증을 위한 수단으로 사용된다.</p>

<h4 id="2-ec2-인스턴스에서-파일-이동하기">2. EC2 인스턴스에서 파일 이동하기</h4>

<p>우선 EC2 인스턴스에 접속 후</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh -i /path/to/your/SSH_Key.pem ec2-user@&lt;EC2_PUBLIC_IP&gt;
</code></pre></div></div>

<p>EC2 서버 내에서 로컬로부터 받은 파일을 Apache 설정 파일로 옮긴다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo mv /home/ubuntu/index.html /var/www/html/
sudo mv /home/ubuntu/style.css /var/www/html/
</code></pre></div></div>

<h4 id="3-파일-권한-설정">3. 파일 권한 설정</h4>

<p>Apache가 파일에 접근할 수 있도록 파일 권한을 수정해야 한다. Apache는 일반적으로 <code class="language-plaintext highlighter-rouge">www-data</code> 사용자로 실행되므로, 다음 명령어로 권한을 설정할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo chown www-data:www-data /var/www/html/index.html
sudo chown www-data:www-data /var/www/html/style.css
</code></pre></div></div>

<h4 id="4-apache-서버-재시작">4. Apache 서버 재시작</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo systemctl restart apache2
</code></pre></div></div>

<p>서버를 재시작하면?</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/79886e4f-671c-45b9-a9ba-e83abd0e84d6/image.png" alt="" /></p>

<p>내가 만든 페이지가 정상적으로 옮겨진 것을 볼 수 있다.</p>

<h3 id="dns-설정">DNS 설정</h3>

<p>나의 EC2 공인 IP가 널리 퍼지면 안되니 무료 도메인을 사용하여 DNS설정을 해주자</p>

<p><strong>DNS</strong> : 도메인 이름과 IP 주소를 서로 변환하는 역할</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/81c9adae-68ea-4773-b939-686fae317575/image.png" alt="" /></p>

<p>여기에 들어가서 로그인 후 도메인 생성 후</p>

<p><strong>current ip</strong> 탭에 EC2 IP를 적어주면 끝!</p>

<p><strong><code class="language-plaintext highlighter-rouge">내가 설정한 주소 이름.duckdns.org</code></strong> 을 주소창에 입력하면 잘 접속이 될 것이다!</p>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Infra" /><category term="AWS" /><category term="AWS" /><summary type="html"><![CDATA[Apache로 웹서버를 구축하고, 배포까지 해보려 했으나 공유기 Admin 설정 문제로 지금까지 미뤄왔던 AWS를 활용한 배포를 해보려한다.]]></summary></entry></feed>