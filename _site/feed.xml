<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-03-25T14:36:15+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Ukja2</title><subtitle>Practice &amp; Practice</subtitle><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><entry><title type="html">「 ComputerNetwork 」 3주 2차시, Application Layer (1)</title><link href="http://localhost:4000/computernetwork/ComputerNetwork_04/" rel="alternate" type="text/html" title="「 ComputerNetwork 」 3주 2차시, Application Layer (1)" /><published>2025-03-25T01:00:00+09:00</published><updated>2025-03-25T01:00:00+09:00</updated><id>http://localhost:4000/computernetwork/ComputerNetwork_04</id><content type="html" xml:base="http://localhost:4000/computernetwork/ComputerNetwork_04/"><![CDATA[<p>Application Layer 에는 다음과 같은 예시가 있다.
<!--more--></p>

<ul>
  <li>social networking</li>
  <li>Web</li>
  <li>text messaging</li>
  <li>e-mail</li>
  <li>multi-user network games</li>
  <li>streaming stored video (YouTube, Hulu, Netflix)</li>
  <li>P2P file sharing</li>
</ul>

<h2 id="creating-a-network-app">Creating a network app</h2>

<ol>
  <li>Application은 End System에서 실행된다.</li>
  <li>이는 네트워크를 통해 데이터를 주고받음</li>
  <li>라우터 같은 네트워크 장치(코어 장비)에는 애플리케이션을 설치하지 않음
    <ul>
      <li>네트워크 장치는 데이터를 “전달”할 뿐, 애플리케이션을 실행하지 않음!</li>
      <li>즉, 우리는 라우터를 프로그래밍할 필요 없이, 사용자 장치에서 애플리케이션을 개발하면 됨</li>
    </ul>
  </li>
</ol>

<h2 id="client-server-paradigm">Client-server paradigm</h2>
<p>클라이언트-서버 모델은 <strong>클라이언트(Client)</strong> 가 <strong>서버(Server)</strong> 에 요청(Request)을 보내고, 서버가 해당 요청을 처리한 후 <strong>응답(Response)</strong> 을 보내주는 구조</p>

<ol>
  <li>서버(Server)의 특징
    <ul>
      <li>항상 켜져 있는(Always-on) 호스트</li>
    </ul>
  </li>
</ol>

<ul>
  <li>고정된(IP Address) 주소 사용
    <ul>
      <li>클라이언트가 언제든지 서버에 접속할 수 있도록 영구적인 IP 주소를 가짐.</li>
    </ul>
  </li>
  <li>대규모 서비스를 위해 데이터센터에 위치
    <ul>
      <li>예를 들어, 넷플릭스의 경우 온갖 영화(데이터)가 데이터센터에 들어가있다고 생각하면 됨</li>
    </ul>
  </li>
</ul>

<ol>
  <li>클라이언트(Client)의 특징
    <ul>
      <li>서버에 접속하여 요청을 보냄</li>
    </ul>
  </li>
</ol>

<ul>
  <li>일시적으로 연결됨(Intermittently connected)
    <ul>
      <li>필요할 때만 서버에 접속하고, 평소에는 네트워크 연결이 없어도 됨.</li>
    </ul>
  </li>
  <li>동적인(Dynamic) IP 주소 사용
    <ul>
      <li>IP address는 한정적이기 때문</li>
    </ul>
  </li>
  <li>클라이언트끼리는 직접 통신하지 않음
    <ul>
      <li>일반적으로 서버를 거쳐야 클라이언트 간 통신이 가능함.</li>
    </ul>
  </li>
</ul>

<h2 id="p2p-peer-to-peer-architecture">P2P (Peer-to-Peer) Architecture</h2>

<p><code class="language-plaintext highlighter-rouge">엔드 유저(클라이언트)</code> 장치들 간 직접 통신하는 구조</p>

<ul>
  <li>서버 없이(peer끼리) 직접 통신</li>
  <li>각 피어(Peer)가 동시에 클라이언트 &amp; 서버 역할 수행</li>
  <li><code class="language-plaintext highlighter-rouge">Self Scalability</code>
    <ul>
      <li>새로운 피어(사용자)가 생기면 서비스 요청자 + 제공자 역할을 동시에 함</li>
      <li>피어가 많아질수록 네트워크 처리량(Throughput)도 증가</li>
      <li>서버 없이도 자연스럽게 확장됨</li>
      <li>즉, <code class="language-plaintext highlighter-rouge">네트워크들의 연결성과 범위를 스스로 줄였다 늘렸다 하는 것을 의미</code></li>
    </ul>
  </li>
  <li>Peer는 네트워크에 일시적으로 연결되고, IP 주소가 자주 변경됨
    <ul>
      <li>관리 복잡 (중앙 관리 서버가 없어서 어려움)</li>
    </ul>
  </li>
</ul>

<h2 id="processes-communicating">Processes Communicating</h2>

<ul>
  <li>프로세스(Process)란? : 운영 중인 프로그램 (CPU에서 실행 중인 프로그램)
    <ul>
      <li>하나의 컴퓨터에는 여러개의 프로세스가 동작가능하다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">프로세스 간 통신 (Inter-Process Communication)</code>
    <ul>
      <li>하나의 호스트에서 OS를 통과해서 앱들끼리 통신을 할 수 있는 것을 의미한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">서로 다른 호스트</code>에 있는 프로세스들은 <strong>메시지</strong> 를 교환하여 통신한다. 
그거를 패킷이라 표현하는데 7계층이라 메세지라고 표현한다.</li>
</ul>

<h2 id="sockets">Sockets</h2>
<p><code class="language-plaintext highlighter-rouge">소켓(Socket)</code>은 네트워크 통신에서 프로세스가 메시지를 보내고 받는 창구를 의미한다.</p>

<p>이는 문에 비유할 수 있는데,</p>
<ul>
  <li>보내는 프로세스는 메시지를 소켓을 통해 “문 밖으로” 보낸다.</li>
  <li>받는 프로세스는 “문 안”에 있는 소켓을 통해 메시지를 받는다.</li>
</ul>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/70cb6cc4-1388-405e-8807-4cbf5b490eb8/image.png" alt="" /></p>

<p>App을 벗어나는 통로를 socket이라 칭한다.</p>

<h2 id="addressing-processes">Addressing Processes</h2>

<p>프로세스가 메시지를 받으려면, 그 프로세스를 식별할 수 있는 고유한 아이디가 필요하다. 이를 위해서 IP 주소와 포트 번호가 사용된다.</p>

<ul>
  <li>IP 주소와 프로세스의 관계
    <ul>
      <li>
        <p>호스트 장치는 고유한 32비트 IP 주소를 가짐.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">하지만, IP 주소만으로는 특정 프로세스를 식별할 수 없다.</code> 왜냐하면 하나의 호스트에서 여러 프로세스가 동시에 실행되기 때문임</p>
      </li>
    </ul>
  </li>
</ul>

<p>즉 프로세스를 식별하기 위한 주소는 <code class="language-plaintext highlighter-rouge">IP 주소</code>와 <code class="language-plaintext highlighter-rouge">포트 번호</code> 두 가지를 포함한다.</p>

<p>비슷한 경우로 로컬 네트워크 내에서 장치간에서는 <code class="language-plaintext highlighter-rouge">Mac Address</code> 를 통해서 통신을 할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">Mac Address?</code> -  물리적 네트워크 장치(예: 컴퓨터, 스마트폰, 라우터 등)에 할당된 고유한 식별자를 의미한다. 이는 변경할 수 없다.</p>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="ComputerNetwork" /><category term="ComputerNetwork" /><summary type="html"><![CDATA[Application Layer 에는 다음과 같은 예시가 있다.]]></summary></entry><entry><title type="html">「 ComputerNetwork 」 3주 1차시, 네트워크 보안 및 계층화</title><link href="http://localhost:4000/computernetwork/ComputerNetwork_03-copy-2/" rel="alternate" type="text/html" title="「 ComputerNetwork 」 3주 1차시, 네트워크 보안 및 계층화" /><published>2025-03-18T01:00:00+09:00</published><updated>2025-03-18T01:00:00+09:00</updated><id>http://localhost:4000/computernetwork/ComputerNetwork_03%20copy%202</id><content type="html" xml:base="http://localhost:4000/computernetwork/ComputerNetwork_03-copy-2/"><![CDATA[<h2 id="network-security">Network Security</h2>

<p>현재의 세대는 인터넷 보안이 매우 중요한데, OSI 7 layer의 모든 부분에서 보안을 신경쓰도록 바뀌었다.
<!--more--></p>

<p>고 단계의 계층으로 갈 수록 암호화의 기술도 고도화할 수 있게 됐다.
예를 들어, 파일의 암호화 등</p>

<h2 id="malware">Malware</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Mal</code>: 그리스어로 나쁜 ,<code class="language-plaintext highlighter-rouge">ware</code>: software = 나쁜 소프트웨어</li>
</ul>

<p>Virus : 사용가자 특정 개체를 실행시 감염
Worm : 사용자의 행동과 무관하게, 직접 수신하면 감염됨</p>

<p>Spyware : 사용자의 컴퓨터에 몰래 접근하여 권한을 얻어내는 멀웨어</p>

<p>DDos : DDOS는? <code class="language-plaintext highlighter-rouge">좀비 컴퓨터(botnet)</code>를 넓은 영역에 펼쳐서  연결된 네트워크들에게 특정 시간에 불필요한 패킷을 마구잡이로 보내는 것</p>

<h3 id="denial-of-service">Denial of service</h3>

<ul>
  <li>Dos: <code class="language-plaintext highlighter-rouge">Denial of Service(서비스를 거절한다.)</code>라는 뜻의 약자</li>
</ul>

<p>공격자가 <strong>가짜 트래픽(bogus traffic)</strong> 으로 리소스(서버, 대역폭)를 과부하(overwhelming) 시켜, 정상적인 사용자(legitimate traffic)가 이를 사용할 수 없도록 만드는 공격</p>

<h3 id="packet-interception">Packet interception</h3>

<p><code class="language-plaintext highlighter-rouge">Packet interception</code> :  네트워크에서 전송 중인 패킷을 가로채는 행위</p>

<p><code class="language-plaintext highlighter-rouge">Packet Sniffing</code> : Interception의 한 방식으로 네트워크에서 전송되는 패킷을 <code class="language-plaintext highlighter-rouge">엿보고(Sniffing)</code> 분석하는 행위</p>

<ul>
  <li>좀더 발전된 사이버 공격으로 <code class="language-plaintext highlighter-rouge">일반 도스 공격</code>은 예를 들어 은행 업무를 아예 사용하지 못하도록 마비시키고, <code class="language-plaintext highlighter-rouge">스니핑</code>은 특정 정보를 빼내오는 기술임</li>
</ul>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/28fbfe3b-8733-48eb-b9df-52dc88987fa8/image.png" alt="" /></p>

<p>로그인 정보가 a로만 가야되는데 중간의 c가 정보를 탈취하는(interception) 것을 보여준다.</p>

<h3 id="fake-identity">fake identity</h3>

<p>IP spoofing: 공격자가 가짜 IP주소를 사용하여 자신을 다른 시스템처럼 보이게하는 기술이다.</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/296de5ec-710e-4fb6-bea7-211d3c86dba2/image.png" alt="" /></p>

<ul>
  <li>
    <p>공격자가 적극적으로 악의적인 행동을 한다.</p>
  </li>
  <li>
    <p>A가 은행서버, B는 피해자</p>
  </li>
  <li>
    <p>c가 스니핑을 통해서 정보를 획득 후,  c가 a인 것처럼 행동, 원래는 c가 a를 공격해야 하는데 그 반대가 되는 경우임</p>
  </li>
</ul>

<hr />

<h2 id="네트워크의-계층화">네트워크의 계층화</h2>

<ol>
  <li><strong>복잡한 시스템의 조직화</strong></li>
</ol>

<ul>
  <li>
    <p>네트워크와 같은 복잡한 시스템은 여러 구성 요소(호스트, 라우터, 링크, 애플리케이션, 프로토콜 등)로 이루어져 있음.</p>
  </li>
  <li>
    <p>이러한 시스템은 <strong><code class="language-plaintext highlighter-rouge">계층화</code></strong> 를 통해 관리하고 이해하기 쉽게 조직할 수 있음.</p>
  </li>
</ul>

<ol>
  <li><strong>항공 여행 과정의 예시</strong></li>
</ol>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/fa93a7c7-21d3-4d2b-abdf-d9c327b40725/image.png" alt="" /></p>

<p>항공 여행 과정에서 각 단계(티켓 구매, 수하물 체크, 비행기 이륙 등)를 네트워크 계층화에 빗대어 설명할 수 있다.</p>

<ol>
  <li><strong>왜 계층화가 필요하며, 수 많은 계층을 만들까?</strong></li>
</ol>

<ul>
  <li>
    <p>계층화는 복잡한 시스템을 더 쉽게 관리하고 단순화하기 위해 사용된다.</p>
  </li>
  <li>
    <p>시스템을 여러 개의 잘 정의된 계층으로 나누어 각 계층이 구조적으로 상호작용하도록 만든다.</p>
  </li>
  <li>
    <p>여러 가지 계층화 모델이나 구성 방법을 많이 시도한 후, 표준화된 규격을 만들어서 네트워크를 구성하는 것이 그 이유</p>
  </li>
</ul>

<h2 id="internet-protocol-stack">Internet protocol stack</h2>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/5fcb4cc4-e99d-4400-b160-8e9ac4dff249/image.png" alt="" /></p>

<ul>
  <li>internet protocol stack에서는 Application 계층이 presentation과 session 계층을 모두 포함한다.</li>
</ul>

<p><strong>OSI 7layer와 차이점?</strong></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">OSI 7계층</code>은 네트워크 통신의 각 단계를 매우 세분화하여 정의한 이론적인 모델이며, <code class="language-plaintext highlighter-rouge">인터넷 프로토콜 스택</code>은 실제로 인터넷에서 데이터를 전송하는 데 사용되는 프로토콜을 기반으로 한 실용적 모델이다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">인터넷 프로토콜 스택</code>은 OSI 모델을 참고하여 설계되었지만, OSI 모델처럼 복잡하게 구분된 계층을 사용하지 않고, 계층을 통합하여 효율성을 추구한다.</p>
  </li>
</ul>

<h2 id="encapsulation">Encapsulation</h2>

<p>Encapsulation : 캡슐화</p>

<p>데이터를 네트워크를 통해 전송할 때, 각 계층은 자신만의 정보를 담은 <strong>헤더(header)</strong> 를 추가하며, 계층이 내려갈 때마다 헤더가 붙는다.</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/c2f95679-d149-4a6f-993d-d550485d93e7/image.png" alt="" /></p>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="ComputerNetwork" /><category term="ComputerNetwork" /><summary type="html"><![CDATA[Network Security 현재의 세대는 인터넷 보안이 매우 중요한데, OSI 7 layer의 모든 부분에서 보안을 신경쓰도록 바뀌었다.]]></summary></entry><entry><title type="html">「 AWS 」 EC2 인스턴스 생성및 접속</title><link href="http://localhost:4000/infra/aws/AWS_Server/" rel="alternate" type="text/html" title="「 AWS 」 EC2 인스턴스 생성및 접속" /><published>2025-03-18T01:00:00+09:00</published><updated>2025-03-18T01:00:00+09:00</updated><id>http://localhost:4000/infra/aws/AWS_Server</id><content type="html" xml:base="http://localhost:4000/infra/aws/AWS_Server/"><![CDATA[<p>Apache로 웹서버를 구축하고, 배포까지 해보려 했으나 공유기 Admin 설정 문제로 지금까지 미뤄왔던 AWS를 활용한 배포를 해보려한다.</p>

<!--more-->

<p><strong>회원가입</strong>을 통해 AWS 계정을 생성해준다. ( 과정 생략 )</p>

<h3 id="ec2-인스턴스-생성">EC2 인스턴스 생성</h3>

<h4 id="1-좌측-상단-검색창에-ec2를-검색한-후-클릭해준다">1. 좌측 상단 검색창에 <strong>EC2</strong>를 검색한 후 클릭해준다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/3a5ac3df-bfc8-4ede-9d1d-55754d613da4/image.png" alt="" /></p>

<h4 id="2-우측-인스턴스-시작을-눌러준다">2. 우측 인스턴스 시작을 눌러준다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/ec63d5df-9736-4df9-8ed6-7b4437562002/image.png" alt="" /></p>

<h4 id="3-인스턴스명은-내가-알아보기-쉽도록-설정하면-된다">3. 인스턴스명은 내가 알아보기 쉽도록 설정하면 된다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/3180b1ae-f8ac-4cf7-b08b-7f9c2a83c9de/image.png" alt="" /></p>

<h4 id="4-ami-설정은-아래의-형식을-따랐다">4. AMI 설정은 아래의 형식을 따랐다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/034a28fb-c710-4ad5-bcdd-88562ae01111/image.png" alt="" /></p>

<p>나는 아직 잘 모르기 때문에 운영체제는 Ubuntu를 골랐으며, 버전은 <code class="language-plaintext highlighter-rouge">24.04 LTS</code> 와 <code class="language-plaintext highlighter-rouge">22.04 LTS</code>가 있는데, 둘 다 프리 티어 사용이 가능해서 아무래도 안정적인 22.04 버전을 사용했다.</p>

<p>아키텍처는 앞선 이유와 동일하게 잘 모르기 때문에 기본설정인 <code class="language-plaintext highlighter-rouge">64비트(x86)</code> 를 사용했다.</p>

<h4 id="5-인스턴스-유형은-프리-티어가-가능한-t2micro-모델을-사용한다">5. 인스턴스 유형은 프리 티어가 가능한 <code class="language-plaintext highlighter-rouge">t2.micro</code> 모델을 사용한다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/b76420fa-20ee-43de-bf67-6c1b39165d10/image.png" alt="" /></p>

<p><strong>EC2 인스턴스 유형(Instance Type)</strong> 은 CPU, 메모리(RAM), 네트워크 성능 등에 따라 분류된 <strong>서버의 스펙(성능 등급)</strong> 이라고 알면 된다.</p>

<h4 id="6-키페어의-이름은-본인이-식별할-수-있도록-설정한다">6. 키페어의 이름은 본인이 식별할 수 있도록 설정한다.</h4>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/36151bf1-77db-4fef-bf43-fd813cb4e48f/image.png" alt="" /></p>

<p>RSA의 보안성이 높고 널리 지원되고 있으며, pem키 또한 다양한 운영 체제에서 사용 가능하게 지원되기 때문에 많이 사용한다고 한다.</p>

<p>또한 키페어는 <strong>절대 유출되어서는 안되기 떄문에</strong> 따로 잘 보관하도록 하자.</p>

<h4 id="7">7.</h4>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Infra" /><category term="AWs" /><category term="AWS" /><summary type="html"><![CDATA[Apache로 웹서버를 구축하고, 배포까지 해보려 했으나 공유기 Admin 설정 문제로 지금까지 미뤄왔던 AWS를 활용한 배포를 해보려한다.]]></summary></entry><entry><title type="html">「 ComputerNetwork 」 2주 2차시, 네트워크 계속, 인터넷 구조, 패킷 딜레이</title><link href="http://localhost:4000/computernetwork/ComputerNetwork01/" rel="alternate" type="text/html" title="「 ComputerNetwork 」 2주 2차시, 네트워크 계속, 인터넷 구조, 패킷 딜레이" /><published>2025-03-16T01:00:00+09:00</published><updated>2025-03-25T14:00:00+09:00</updated><id>http://localhost:4000/computernetwork/ComputerNetwork01</id><content type="html" xml:base="http://localhost:4000/computernetwork/ComputerNetwork01/"><![CDATA[<h2 id="network-core">Network core</h2>

<p>ISP 내부에는 <code class="language-plaintext highlighter-rouge">Network core</code>와 <code class="language-plaintext highlighter-rouge">Network Edge</code>가 있다.</p>

<!--more-->

<p>어떠한 정보를 보낼 때 네트워크 코어에서 데이터를 처리하는 두 가지 전송 방식이 존재한다.</p>

<ol>
  <li>Circuit Switching - 고정된 경로(회선) 를 설정하고, 데이터가 이 경로를 따라 전송되는 방식</li>
  <li>Packet Switching - 박스에 정보를 담아 전송하는 방식</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">스위치</code>나 <code class="language-plaintext highlighter-rouge">라우터</code>가 있어야 현재의 네트워크에서 다른 네트워크로 전송이 가능함</p>

<ul>
  <li>Forwarding (전달하다) - 패킷을 라우터에서 라우터, 다른 호스트로 전달하는 과정을 의미
    <ul>
      <li>즉 데이터를 생성한 사람은 내가 아니며, 누군가로 부터 받은 데이터를 다른 쪽으로 전송하는 것이다.</li>
    </ul>
  </li>
</ul>

<h3 id="packet-switching-store-and-forward">Packet-switching: store-and-forward</h3>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/cc6eab54-5b9f-47be-8497-b0c548c6829a/image.png" alt="" /></p>

<p>Packet Swtiching 방식은 store and forward 방식으로 작동한다.</p>

<p>source에서 L개의 비트로 이루어진 패킷을 보내려고 하면, 라우터 내부의 <code class="language-plaintext highlighter-rouge">buffer</code>에 해당 패킷을 저장 후 라우터는 버퍼에 들어온 순서대로 패킷을 정해진 destination으로 <code class="language-plaintext highlighter-rouge">전달한다</code> .</p>

<p>패킷전송지연률 = L / R</p>

<p><code class="language-plaintext highlighter-rouge">End to End Delay</code> : 데이터가 출발지에서 목적지까지 전달되는 데 걸리는 전체 시간 = 2L/R</p>

<p>라우터 하나를 거칠 때 2L 이며 이후 N개 만큼 곱한다.</p>

<p><code class="language-plaintext highlighter-rouge">hop</code> : 패킷의 이동 단위</p>

<p>위 그림에서 source에서 라우터까지의 한 번의 이동이 1hop이 된다.</p>

<h3 id="packet-switching-queueing-delay-loss">Packet-switching: queueing delay, loss</h3>
<p><img src="https://velog.velcdn.com/images/ghkdehs/post/af6425b3-da50-4655-9e53-62ff0cbf3140/image.png" alt="" /></p>

<p>원래 Packet switching은 여러 개의 컴퓨터가 하나의 스위치나 라우터에 연결되어서 네트워크를 좀 더 효율적으로 쓰기 위함으로 위 그림이 좀 더 현실적이라 할 수 있다.</p>

<p>위의 그림예시로 A컴퓨터에서 패킷을 보내는 속도가 100Mb/s고 라우터가 처리하는 속도가 1.5Mb/s 일 때 라우터의 buffer가 전부 차면 아직 처리되지 못한 패킷을 삭제하고 새로운 패킷이 들어오게 되는데 이를 <code class="language-plaintext highlighter-rouge">loss</code> 라고 칭한다.</p>

<h3 id="two-key-network-core-functions">Two key network-core functions</h3>

<p>네트워크 코어의 두 가지 주요 기능</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/b30c9a89-7e2b-4f76-9f56-ce03b5f9ce9e/image.png" alt="" /></p>

<p>위 이미지는 여러 라우터 간 연결을 보여주며, 라우팅 알고리즘이 패킷의 최적 경로를 선택하는 과정을 나타낸다</p>

<ul>
  <li>Forwarding (포워딩)
로컬 작업 - 라우터 하나의 관점에서 보는 것
    <ul>
      <li>패킷의 헤더 값에 따라 <strong>local forwarding table(로컬 포워딩 테이블)</strong> 을 참조하여 출력 링크를 결정한다</li>
      <li>예를 들어, 패킷의 헤더 값이 “0111”이라면, 테이블에 따라 출력 링크 “2”로 이동한다.</li>
    </ul>
  </li>
  <li>Routing (라우팅)
글로벌 작업: 라우터들 끼리 이어져있는 전체적인 구성에서의 관점으로 보는 것
    <ul>
      <li>이는 네트워크 전체에서 경로를 설정하며, 라우팅 알고리즘을 통해 진행된다</li>
    </ul>
  </li>
</ul>

<h3 id="circuit-switching-fdm-and-tdm">Circuit switching: FDM and TDM</h3>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/577d8c93-c27d-484a-84fa-f235da93f9e4/image.png" alt="" /></p>

<p>하나의 네트워크를 다수의 유저가  통신 자원인 <code class="language-plaintext highlighter-rouge">주파수</code> 와 <code class="language-plaintext highlighter-rouge">시간</code> 을  활용해서 효율적으로 나눠 쓰도록 하기 위한 기술</p>

<ul>
  <li>Frequency Division Multiplexing (FDM)
    <ul>
      <li>주파수를 여러 개의 작은 대역으로 나눠서 각각 할당하는 방식</li>
      <li>각 사용자는 특정 주파수 대역을 계속 사용 가능</li>
    </ul>
  </li>
  <li>Time Division Multiplexing (TDM)
    <ul>
      <li>시간을 여러 개의 슬롯으로 나누고, 각 사용자에게 특정 시간 동안만 전송 기회를 주는 방식</li>
      <li>모든 사용자가 넓은 주파수 대역을 사용할 수 있지만, 특정 시간 슬롯에서만 전송 가능</li>
    </ul>
  </li>
</ul>

<p>fdm을 쓰든 tdm을 쓰든 데이터의 총량(엔트로피)는 정해져있음 가로로 쓰냐 세로로 쓰냐의 차이일 뿐이다</p>

<h3 id="packet-switching-vs-circuit-switching">Packet switching VS circuit switching</h3>

<p>결론적으로 패킷스위칭이 좋다</p>

<p>대부분의 부분에서 패킷 스위칭으로 전환이 되어가는 중임 (전화까지도)</p>

<hr />

<h2 id="internet-structure">Internet structure</h2>

<p>과거의 인터넷 구조에서는 네트워크 간의 연결을 하나씩 설정하고 직접 연결하는 방식이었음</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/9cba6c73-ff5d-4673-b40b-7b0ffa4bc99a/image.png" alt="" /></p>

<p>허나 이러한 방식은 원래는 각각의 액세스를 직접 연결해서 사용했기 때문에 그 개수의 제곱만큼의 연결선이 발생해서 비용적인 측면에서 매우 비효율적이었음</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/8a003087-b36c-4d6e-bf74-879d0ad0eadd/image.png" alt="" /></p>

<p>이후 중앙 ISP가 생기고, 트래픅 흐름을 효율적으로 관리할 수 있게 되었다.</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/1b865831-b8b0-463a-942d-85ba7303e440/image.png" alt="" /></p>

<p>하지만 글로벌 ISP는 다양하게 존재하고, 글로벌 ISP간의 데이터 교환을 위해 <code class="language-plaintext highlighter-rouge">IXP(Internet Exchange Point)</code>를 두어 다른 지역은 ISP여도 서로간의 데이터를 공유할 수 있게 됐다.</p>

<h3 id="인터넷-계층-구조">인터넷 계층 구조</h3>
<p><img src="https://velog.velcdn.com/images/ghkdehs/post/7f25a009-2e8b-4435-8220-e533e5517ef3/image.png" alt="" /></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Tier 1 ISP</code>
Tier 1 ISP는 국제적 및 국가적 단위에서 인터넷 제공하는 상위 ISP</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Content Provider Networks (CPN)</code>
    <ul>
      <li>인터넷 콘텐츠를 제공하는 서비스나 플랫폼이 운영하는 네트워크</li>
      <li>CPN 또한 사용자가 접속하려고 할떄 중개자인 ISP를 거쳐서 데이터를 받을 수 있다.</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">IXP</code>
IXP는 여러 네트워크가 서로 데이터를 교환하는 물리적 장소</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Reginal ISP</code>
    <ul>
      <li>지역적으로 인터넷 서비스를 제공하는 ISP 예로 한국의 kt, lg, u+ 등이 있다.</li>
      <li>Tier 1 ISP나 IXP와 연결되어 있으며, Access ISP를 통해 최종 사용자에게 서비스를 제공</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Access ISP</code>
가장 하위 계층의 ISP로 지역 ISP를 통해 인터넷에 연결됩니다.</li>
</ul>

<hr />

<h2 id="packet-delay">Packet Delay</h2>

<p>Packet delay는 패킷이 출발지에서 목적지까지 전송되는 동안 발생하는 총 지연 시간을 의미하며, 크게 4가지 주요 원인으로 나눌 수 있다.</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/a443faa8-2a3e-4dbd-bc8b-9e22dd1f4ff1/image.png" alt="" /></p>

<p>1.Processing delay
연산이 복잡한 알고리즘을 돌리거나 창을 여러개 켜놓을 때에 발생하는 지연, 즉 연산을 처리할 때 걸리는 지연시간</p>

<p>2.queueing delay
라우터 버퍼에서 패킷이 출력되는 동안 지연되는 시간</p>

<p>3.Transmission delay
패킷이 전송될 때 걸리는 시간</p>

<p>4.propagation
거리 / 전파 속도</p>

<p>즉 <code class="language-plaintext highlighter-rouge">패킷의 전체 지연 시간</code>은 네 가지 지연 요소의 합으로 구할 수 있다.</p>

<ul>
  <li>
    <p>이 네 가지 지연요소 외에 남은 요소가 있다면?
-&gt; 목적지 라우터로부터 확답을 받을 때 까지 걸리는 딜레이가 있다.</p>
  </li>
  <li>
    <p>반대로 확답을 받지못해 재전송한다면? 
-&gt; trans , porp 그리고 Echo Request를 받는 시간까지 추가 지연 발생</p>
  </li>
</ul>

<h2 id="caravan-analogy">Caravan analogy</h2>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/014cf9a8-1ca3-43cb-8470-a83b0728d552/image.png" alt="" /></p>

<p>여기 자동차 한 대는 네트워크에서의 <code class="language-plaintext highlighter-rouge">비트</code>를, 10대의 자동차로 이루어진 카라반은 <code class="language-plaintext highlighter-rouge">패킷</code>을 의미한다</p>

<p>속도와 처리 시간:</p>

<ul>
  <li>
    <p>자동차는 시속 100km로 이동한다 (전송 속도)</p>
  </li>
  <li>
    <p>톨게이트(라우터)는 한 대의 자동차를 처리하는 데 12초가 걸린다. (비트 전송 시간).</p>
  </li>
</ul>

<blockquote>
  <p>첫 번째 톨게이트를 통과한 카라반이 두 번째 톨게이트에 도착하여 정렬되기까지 걸리는 시간은?</p>
</blockquote>

<ul>
  <li>첫 번째 톨게이트에서 카라반 처리 시간:</li>
</ul>

<p>각 자동차를 처리하는 데 12초가 걸리므로, 전체 카라반(10대)을 처리하는 데 
<code class="language-plaintext highlighter-rouge">12 × 10 = 120</code> -&gt; 120초</p>

<ul>
  <li>두 번째 톨게이트까지 이동 시간:</li>
</ul>

<p>마지막 자동차가 첫 번째 톨게이트를 떠난 후 두 번째 톨게이트까지 이동하는 데 걸리는 시간은</p>

<p><code class="language-plaintext highlighter-rouge">100km/(100km/hr)</code> -&gt; 1시간</p>

<ul>
  <li>총 소요 시간:</li>
</ul>

<p>첫 번째 톨게이트에서 카라반을 모두 처리하는 데 걸린 시간(120초 = 2분)과 마지막 자동차가 두 번째 톨게이트까지 도달하는 데 걸린 시간(1시간)을 합산하면 총  62분이 소요된다.</p>

<h2 id="packet-queueing-delay">Packet queueing delay</h2>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/600abe2e-7fff-488e-8812-f7b9927aba78/image.png" alt="" /></p>

<p>R: 링크 대역폭 (bps, 초당 비트 전송 속도)</p>

<p>L: 패킷 길이 (bits, 패킷의 크기)</p>

<p>a: 평균 패킷 도착률 (초당 도착하는 패킷 수)</p>

<p>La/R≈0: 트래픽 강도가 낮아 평균 큐잉 지연이 작음.</p>

<p>La/R→1: 트래픽 강도가 높아져 평균 큐잉 지연이 커짐.</p>

<p>La/R&gt;1: 도착하는 작업량이 서비스 가능한 양을 초과하여 지연 시간이 무한대가 됨.</p>

<h2 id="packet-loss">Packet loss</h2>

<ul>
  <li>
    <p>버퍼 내부의 원래 전송되어야 하는 패킷이 네트워크에서 사라지는 것을 의미</p>
  </li>
  <li>
    <p>패킷이 도착하는 속도가 보내는 속도보다 빠를때 발생</p>
  </li>
  <li>
    <p>일정 버퍼 메모리가 초과되면 <code class="language-plaintext highlighter-rouge">패킷이 삭제되는데 (buffer overwrite)</code>이를 <code class="language-plaintext highlighter-rouge">packet loss</code> 라고함</p>
  </li>
</ul>

<h2 id="throughput">Throughput</h2>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/b164bb99-2fd8-4adf-90b6-237fe4607b86/image.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">Througput(처리랑)</code>? : 단위 시간당 전송된 데이터의 양을 의미한다. 쉽게 말해서, 네트워크가 실제로 전달할 수 있는 속도를 나타냄</p>

<p>위 그림은 각각 two hop network에서 파이프라인의 크기에 따른 처리량을 나타낸다.</p>

<ul>
  <li>
    <p>1번은 서버 -&gt; 라우터의 파이프라인이 좁고, 라우터 -&gt; 컴퓨터의 파이프라인의 크기가 넓다.</p>
  </li>
  <li>
    <p>2번은 그 반대의 경우이다.</p>
  </li>
</ul>

<p>하지만 throughput의 크기는 작은 throughput이 결정한다 큰 게 결정하는게 아님</p>

<p>예를 들어 2번 그림을 보면 Rs속도 만큼 라우터에게 보내는데, 컴퓨로 보낼때는 파이프라인이 좁기 때문에 받은 만큼 전부 보내줄 수가 없게된다. 즉 보낼 수 있는건 Rc만큼이 된다</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bottleneck link(병목현상)</code>  : 병의 입구처럼 크기가 줄어들면 원래 보낼 속도만큼을 보낼 수 없게 된다.</li>
</ul>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="ComputerNetwork" /><category term="ComputerNetwork" /><summary type="html"><![CDATA[Network core ISP 내부에는 Network core와 Network Edge가 있다.]]></summary></entry><entry><title type="html">「 ComputerNetwork 」 1주 ~ 2주 1차시, 네트워크 소개 및 OSI 7 계층</title><link href="http://localhost:4000/computernetwork/ComputerNetwork/" rel="alternate" type="text/html" title="「 ComputerNetwork 」 1주 ~ 2주 1차시, 네트워크 소개 및 OSI 7 계층" /><published>2025-03-11T01:00:00+09:00</published><updated>2025-03-11T01:00:00+09:00</updated><id>http://localhost:4000/computernetwork/ComputerNetwork</id><content type="html" xml:base="http://localhost:4000/computernetwork/ComputerNetwork/"><![CDATA[<h2 id="컴퓨터-네트워크-개요">컴퓨터 네트워크 개요</h2>
<!--more-->

<ul>
  <li>
    <p>프로토콜이란 무엇인가?</p>
  </li>
  <li>
    <p>네트워크 엣지: 호스트, 액세스 네트워크, 물리적 매체</p>
  </li>
  <li>
    <p>네트워크 코어: 패킷/회선 교환, 인터넷 구조</p>
  </li>
  <li>
    <p>프로토콜 계층, 서비스 모델</p>
  </li>
</ul>

<hr />

<h2 id="introduction">Introduction</h2>

<h4 id="1️⃣-billions-of-connected-computing-devices">1️⃣ Billions of connected computing <code class="language-plaintext highlighter-rouge">devices</code></h4>
<p>수십억 개의 연결된 컴퓨터 장치들</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Hosts</code> = end system<br />
호스트는 종단 시스템으로 사용자가 직접 사용하는 장치 (스마트폰, pc) 등을 의미한다.</li>
  <li>running network apps at Internet’s “edge”
인터넷의 “끝부분(엣지)”에서 네트워크 애플리케이션 실행
(웹 브라우저, 이메일, 동영상 스트리밍 같은 네트워크 기반 프로그램 실행)</li>
</ul>

<h4 id="2️⃣-packet-switches">2️⃣ Packet switches</h4>
<p>데이터를 작은 조각(패킷)으로 나눠서 전달하는 장치</p>
<ul>
  <li>인터넷에서 데이터를 한 번에 보내기 힘드니까, 작은 패킷으로 잘라서 보냄.</li>
  <li>
    <p>각 패킷은 주소, 순서, 내용을 가지고 있고, 목적지에서 다시 조립됨</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">routers</code>, <code class="language-plaintext highlighter-rouge">switches</code> : 패킷 스위치의 한 종류로 패킷을 목적지로 보내는 역할</li>
</ul>

<h4 id="3️⃣-communication-links">3️⃣ Communication links</h4>
<p>통신 링크 (장치 간 데이터 전달 경로)</p>

<ul>
  <li>fiber, copper, radio, satellite 
광섬유, 구리선, 무선(라디오), 위성</li>
  <li>transmission rate: bandwidth
전송 속도: 대역폭 (일정 시간 동안 전송 가능한 데이터 양)</li>
</ul>

<h4 id="4️⃣-networks">4️⃣ Networks</h4>
<p>네트워크 (장치, 라우터, 링크의 집합체)</p>

<ul>
  <li>장치, 라우터, 링크로 이루어진 집합: ISP(인터넷 서비스 제공자)”나 “네트워크 관리자” 에 의해 관리됨</li>
</ul>

<h4 id="5️⃣-internet-network-of-networks">5️⃣ Internet: “network of networks”</h4>
<p>인터넷은 네트워크들의 네트워크</p>
<ul>
  <li>인터넷은 전 세계 수많은 작은 네트워크들이 연결된 거대한 네트워크
(예: 집, 학교, 회사의 네트워크가 인터넷을 통해 서로 연결됨)</li>
</ul>

<h4 id="6️⃣-protocols-are-everywhere">6️⃣ <code class="language-plaintext highlighter-rouge">Protocols</code> are everywhere</h4>
<ul>
  <li>
    <p><strong>프로토콜은 데이터를 주고받는 규칙</strong>
네트워크에서 정해진 규칙이 없으면 서로 이해할 수 없으니까 꼭 필요함</p>
  </li>
  <li>
    <p>프로토콜의 역할 : 메시지 전송과 수신을 제어</p>
  </li>
</ul>

<p><strong>대표적인 프로토콜 예시</strong></p>
<ul>
  <li>HTTP: 웹 페이지를 주고받는 규칙 (인터넷 브라우징)</li>
  <li>TCP/IP: 데이터가 안전하게 전송되도록 보장</li>
  <li>Wi-Fi: 무선 네트워크 연결</li>
  <li>4G: 모바일 데이터 통신</li>
  <li>Ethernet: 유선 네트워크 통신</li>
  <li>CAN: 자동차에서 쓰는 통신 규약</li>
</ul>

<h4 id="7️⃣-internet-standards">7️⃣ Internet standards</h4>
<p>인터넷 표준 : 인터넷에서 사용하는 공식 규칙</p>

<ul>
  <li>
    <p>RFC (Request for Comments)
인터넷 표준을 정의하는 문서
새로운 기술이나 프로토콜을 만들 때 RFC 문서로 공개하고 의견을 받음
(예: HTTP, TCP/IP 같은 중요한 기술도 RFC로 시작)</p>
  </li>
  <li>
    <p>IETF (Internet Engineering Task Force)
인터넷 표준을 만드는 국제 기구
새로운 프로토콜이나 보안 규칙을 논의하고 표준으로 정함</p>
  </li>
</ul>

<h4 id="8️⃣-infrastructure-that-provides-services-to-applications">8️⃣ Infrastructure that provides services to applications</h4>
<p>애플리케이션에 서비스를 제공하는 인프라</p>

<p>물리적이고 기술적인 자원들이 모여서 어떤 시스템이나 서비스를 운영할 수 있게 해주는 기반을 말함</p>

<p>즉, 인프라는 <strong>하드웨어(서버, 라우터)</strong> 와 <strong>소프트웨어(프로토콜, 시스템)</strong> 를 모두 포함</p>

<hr />

<h2 id="protocols-프로토콜">Protocols (프로토콜)</h2>
<ul>
  <li>
    <h4 id="human-protocols-사람-간의-프로토콜">Human protocols (사람 간의 프로토콜)</h4>
    <p>사람들이 서로 소통할 때도 <strong>정해진 규칙(프로토콜)</strong> 이 있음</p>
  </li>
</ul>

<p>예를 들어</p>
<ul>
  <li>“몇 시야?” (정보 요청)</li>
  <li>“질문 있어.” (대화 시작)</li>
  <li>자기소개 (처음 만날 때 인사)</li>
</ul>

<p>-&gt; 우리가 대화할 때도 말하는 순서와 방식을 지키는 것처럼, 네트워크에서도 이런 규칙이 필요</p>

<ul>
  <li>
    <h4 id="network-protocols-네트워크-프로토콜">Network protocols (네트워크 프로토콜)</h4>
    <p>사람 대신에 <strong>컴퓨터(기기)</strong> 가 서로 소통할 때 사용하는 규칙
인터넷에서 이루어지는 모든 통신 활동은 이 규칙에 따라 움직임</p>
  </li>
</ul>

<p><strong>프로토콜이 정의하는 것</strong></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">메시지 형식 (format)</code> :
메시지가 어떤 구조로 이루어져 있는지 (ex. 헤더, 페이로드)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">메시지 순서 (order)</code> :
어떤 메시지를 먼저 보내고, 다음에 무엇을 보낼지</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">전송 및 수신 시 동작 (actions)</code> :
메시지를 보낼 때와 받을 때 각각 무슨 행동을 해야 하는지</p>
  </li>
</ul>

<blockquote>
  <p>즉 프로토콜은 컴퓨터 간 통신에서 메시지의 형식, 순서, 행동을 정의하는 규칙이다.</p>
</blockquote>

<hr />

<h2 id="network-edge-네트워크-엣지">Network Edge (네트워크 엣지)</h2>
<p>네트워크 엣지는 인터넷의 끝부분으로, <code class="language-plaintext highlighter-rouge">사용자가 인터넷에 접속하는 지점(호스트)</code>이다.</p>

<ul>
  <li>Hosts: Clients and Servers</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">클라이언트</code>: 인터넷을 통해 서비스를 요청하는 장치 (예: 스마트폰, PC)
<code class="language-plaintext highlighter-rouge">서버</code>: 인터넷에서 서비스를 제공하는 장치 (예: 웹 서버, 데이터베이스 서버)</p>

<p><code class="language-plaintext highlighter-rouge">클라이언트</code>와 <code class="language-plaintext highlighter-rouge">서버</code>는 서로 데이터를 주고받으며 인터넷 상에서 서비스를 주고받는 관계다. 해당 수업에서는 둘의 구별을 두지 않는 걸로 가정</p>

<ul>
  <li>Servers Often in Data Centers : 서버는 보통 데이터 센터에  존재</li>
</ul>

<p>즉, 네트워크 엣지는 클라이언트(사용자)와 서버가 서로 소통하는 지점, 그리고 이 지점에서 호스트들이 연결되고 통신한다.</p>

<ul>
  <li>Access networks, physical media (액세스 네트워크, 매질) : 
액세스 네트워크는 사용자가 인터넷에 접속하는 부분이고, 유선 또는 무선 링크를 통해 데이터를 주고받음</li>
</ul>

<hr />

<h2 id="network-core-네트워크-코어">Network core (네트워크 코어)</h2>
<p>interconnected routers: 서로 연결된 라우터들</p>

<p>→ 네트워크 간에 여러 라우터들이 서로 연결되어 데이터를 목적지까지 전달함</p>

<p>network of networks: 네트워크들의 네트워크</p>

<p>→ 인터넷은 작은 네트워크들이 모여서 이루어진 거대한 네트워크</p>

<p><code class="language-plaintext highlighter-rouge">네트워크 코어</code>: 여러 라우터들이 서로 연결되어 다양한 네트워크를 하나로 묶는 중심 부분</p>

<hr />

<h2 id="transmission-rate전송률--bandwidth대역폭">Transmission rate(전송률) &amp; Bandwidth(대역폭)</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Transmission rate(전송률)</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">bps(단위)</code> : bit / second -&gt; 1/S = ———-
초당 몇개의 비트를 네트워크를 통해서 보낼 수 있는지
Ex 강한 압력으로 파이프에 물을 넣으면 1초 동안 물을 더 많이 보낼 수 있게 된다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Bandwidth(대역폭)</code>
Ex 동일한 압력으로 물을 넣을 때 파이프의 직경이 클수록 더 많은 물을 보낼 수 있게 된다.</li>
</ul>

<p>즉 개념적인 부분에서 대역폭은 네트워크가 최대로 전송할 수 있는 용량이며, 전송률은 전송되는 데이터의 속도를 의미한다.</p>

<p>이 차이를 알 필요가 있다.</p>

<hr />

<h2 id="fdmfrequency-division-multiplexing">FDM(Frequency Division Multiplexing)</h2>
<ul>
  <li>
    <p>하나의 통신 채널을 여러 개의 주파수 대역으로 나누어 여러 신호를 동시에 전송하는 방식이다.</p>
  </li>
  <li>
    <p>각 신호는 서로 다른 주파수 대역을 사용하므로 <code class="language-plaintext highlighter-rouge">간섭</code> 이 없다.</p>
  </li>
  <li>
    <p>예를 들어 무전기와 라디오 같이 특정 대역을 정하면 그 대역으로 통신할 수 있게 된다.</p>
  </li>
  <li>
    <p>멀티플렉싱을 할 수 있는 방법으로 1. 시간대를 나누거나 2. 주파수 대역을 나눈 방식이 있다.</p>
  </li>
</ul>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/dbec666c-bb7f-46ef-aa07-7d6c94605d8c/image.png" alt="" /></p>

<h2 id="osi-7-layer">OSI 7 Layer</h2>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/dc03e147-a1f7-4c90-b5a7-ba9c71b74771/image.png" alt="" />
ISO/OSI reference model 이라고 부른다.</p>

<ul>
  <li>국제표준기구(ISO)에서 컴퓨너 네트워크를 구성할 때 어떤 것들이 필요한지 모든 기능들을 상세하게 분석한 후, 이 정도의 기능들을 다루는 <code class="language-plaintext highlighter-rouge">Layer</code>가 있어야 완전한 통신이 된다고 정의함</li>
</ul>

<p>해당 강의 에서는 Top-Down 방식으로 진행 예정이며, 간단한 설명만 아래에서부터 시작</p>

<h4 id="1️⃣-physical">1️⃣ Physical</h4>
<p>실제 데이터가 전송되는 물리적인 매체(케이블, 전파, 광섬유 등)를 다루는 계층</p>

<h4 id="2️⃣-link">2️⃣ Link</h4>
<p>물리 계층(1계층)에서 받은 데이터를 신뢰성 있게 전송하도록 관리하는 계층</p>

<p>어딘가에 데이터를 보낼 때 내가 사용할 수 있는 media(데이터가 전송되는 매체)`을 할당해준다.
= 데이터를 보낼 경로를 MAC 주소를 통해 어떤 장치로 보낼지 결정하고, 그 경로(유선, 무선)에 따라 데이터를 전송하는 걸 의미</p>

<h4 id="3️⃣-network">3️⃣ Network</h4>
<p>어떠한 목적지까지의 데이터를 전달하는 <code class="language-plaintext highlighter-rouge">라우팅</code>을 담당한다.</p>
<blockquote>
  <p><strong>라우팅</strong> : 네트워크 내에서 데이터를 전달할 경로를 설정하고 관리하는 과정</p>
</blockquote>

<ul>
  <li>
    <p>즉, 네트워크간의 연결에서 어떤 경로로 데이터를 보낼지 결정하는 것이 3계층의 역할이다.</p>
  </li>
  <li>
    <p>예를 들어 대구에서 서울로 간다고 가정했을 때, 어떤 도시를 거쳐서 갈 것인지 네비게이션이 최적의 경로를 설정하는 경우</p>
  </li>
</ul>

<h4 id="4️⃣-transport">4️⃣ Transport</h4>
<p>Transport Layer는 데이터를 <code class="language-plaintext highlighter-rouge">보낸 사람</code>과 <code class="language-plaintext highlighter-rouge">받은 사람</code> 사이에서 정확하고 신뢰성 있는 통신을 보장하는 역할을 한다.</p>

<ul>
  <li>주요 기능
    <ul>
      <li>큰 데이터를 작은 데이터로 패킷화</li>
      <li>데이터 손상 유무를 체크하고, 이상이 있을 시 재전송 요청</li>
      <li>데이터의 양을 조절해서 흐름 제어</li>
      <li>데이터 전송 시작 전에 연결을 설정하고, 받은 후 연결 종료</li>
    </ul>
  </li>
</ul>

<p>이 모든 특징은 택배 회사를 통해 택배를 보내는 흐름과 유사하다.</p>

<h4 id="5️⃣-session">5️⃣ Session</h4>
<p>데이터 교환의 흐름을 제어하고, 동기화나 복구를 처리하는 역할</p>

<h4 id="6️⃣-presentation">6️⃣ Presentation</h4>
<p>데이터를 사람이 이해할 수 있는 형태로 변환 (부호화, 압축, 암호화)</p>

<ul>
  <li>주요 기능
    <ul>
      <li>데이터 변환 (Data Translation) : 서로 다른 시스템 간 데이터 변환</li>
      <li>암호화/복호화 (Encryption/Decryption) : 보안 강화 (예: SSL/TLS)</li>
      <li>압축 (Compression) : 전송 속도 향상 (예: ZIP, MP3, JPEG)</li>
    </ul>
  </li>
</ul>

<h4 id="7️⃣-applications">7️⃣ applications</h4>
<p>사용자가 직접 접하는 소프트웨어나 서비스 제공</p>

<hr />

<h2 id="host--packet-transmission-delay-패킷-전송-지연률">Host : packet transmission delay (패킷 전송 지연률)</h2>

<p>패킷 전송 지연 계산</p>

<p>어떠한 패킷을 전송하는 데 걸리는 시간은 아래와 같이 계산</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/eb6be68d-3384-4293-b232-5c8218a06f58/image.png" alt="" /></p>

<p>L: 패킷의 크기 (비트 단위)</p>

<p>R: 링크의 전송 속도 (비트/초)</p>

<p>l개의 비트로 r이라는 bps를 통해 걸리는 시간을 계산하는 것이 곧 지연률이 된다.</p>

<p>만약 packet transmission delay를 구할 때 단위는 <code class="language-plaintext highlighter-rouge">초</code>가 나와야 된다.</p>

<hr />

<h2 id="link--guided-media-unguided-media">Link : Guided media, Unguided media</h2>

<p>이 둘의 기준을 어떠한 정보를 전송하는데 이 정보를 누구나 받을 수 있냐와 없냐의 차이로 볼 수 있다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Guided media</code> : 어떠한 물리적인 전선, 케이블을 통해 전송되는 매체
    <ul>
      <li>전선, 광섬유 케이블(Fiber)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Unguided media</code> : 물리적인 전선 등 없이 공기나 진공을 통해 자유롭게 전송하는 방식
    <ul>
      <li>라디오</li>
    </ul>
  </li>
</ul>

<h3 id="link--physical-media">Link : Physical media</h3>
<ul>
  <li>Coaxial cable</li>
  <li>Fiber optic cable</li>
  <li>Wireless radio
    <ul>
      <li>물리적인 전선을 쓰지는 않지만 <code class="language-plaintext highlighter-rouge">전파</code> 라는 신호가 실제의 공기를 통해 전달되기 때문에 Physical media의 일종이다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">half-duplex</code></strong> : 양방향 통신에서 한 번에 하나의 방향으로만 데이터 전송이 가능한 방식
예를 들어 무전기가 있다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="ComputerNetwork" /><category term="ComputerNetwork" /><summary type="html"><![CDATA[컴퓨터 네트워크 개요]]></summary></entry><entry><title type="html">「 Linux 」 Apache Web Server 구축 (1)</title><link href="http://localhost:4000/linux/infra/Apache-Web_Server/" rel="alternate" type="text/html" title="「 Linux 」 Apache Web Server 구축 (1)" /><published>2025-03-04T01:00:00+09:00</published><updated>2025-03-04T01:00:00+09:00</updated><id>http://localhost:4000/linux/infra/Apache-Web_Server</id><content type="html" xml:base="http://localhost:4000/linux/infra/Apache-Web_Server/"><![CDATA[<h2 id="리눅스-웹-서버-구축">리눅스 웹 서버 구축</h2>
<p>오픈 소스 웹 서버 소프트웨어인 <code class="language-plaintext highlighter-rouge">Apache</code> 를 사용해서 웹 서버를 구축해보려 한다.
<!--more--></p>

<h3 id="-웹-서버">🌍 웹 서버?</h3>
<ul>
  <li>
    <p>웹 서버는 사용자가 웹 브라우저에서 요청한 웹 페이지를 제공하는 서버. 쉽게 말해서, 웹 사이트를 실행하는 컴퓨터라고 생각할 수 있음.</p>
  </li>
  <li>
    <p>웹 서버는 HTTP 프로토콜을 사용해서 클라이언트(브라우저)와 서버 간에 데이터를 주고받음</p>
  </li>
</ul>

<hr />

<p>나는 MacOS 환경에서 진행하기에 이에 맞는 방법으로 시작할 것이다.</p>

<h3 id="1️⃣-apache-설치">1️⃣ Apache 설치</h3>
<blockquote>
  <p>brew install httpd</p>
</blockquote>

<p>터미널에서 Homebrew를  통해 Apahce를 설치한다.</p>

<h3 id="2️⃣apache-웹-서버-시작">2️⃣Apache 웹 서버 시작</h3>
<blockquote>
  <p>sudo apachectl start</p>
</blockquote>

<p>터미널에서 위 명령어를 치면 Apache 서버를 시작할 수 있다.</p>

<p>주소창에 <code class="language-plaintext highlighter-rouge">http://localhost</code> 을 입력해보자.</p>

<ul>
  <li>서버 중지
    <blockquote>
      <p>sudo apachectl stop</p>
    </blockquote>
  </li>
  <li>서버 재시작
    <blockquote>
      <p>sudo apachectl restart</p>
    </blockquote>
  </li>
</ul>

<h3 id="️-오류-발생-시-팁">⚠️ 오류 발생 시 팁</h3>
<p>하지만 대부분의 경우 처음 Apache 서버를 시작할 때 <code class="language-plaintext highlighter-rouge">AH00558</code>라고 적힌 에러코드를 발견할 수 있을 것이다.</p>

<p>이는 Apache 서버의 전역의 지시문으로 Servername에 대한 설정이 누락된 것으로, 해당 부분을 localhost로 변경해주면 된다.</p>

<blockquote>
  <p>sudo nano /etc/apache2/httpd.conf</p>
</blockquote>

<p>위 명령을 통해 텍스트파일 편집기로 <code class="language-plaintext highlighter-rouge">httpd.conf</code> 파일 내부에 <code class="language-plaintext highlighter-rouge">^w</code> 단축키로 <strong>Servername</strong> 을 입력하면 <code class="language-plaintext highlighter-rouge">#Servername ~~~</code> 와 같이 주석처리 되어있는 Servername을 확인할 수 있다. 여기서 <code class="language-plaintext highlighter-rouge">#</code>을 제거해주고 
Apache를 재시작해주면 정상적으로 <strong>작동할 수도 있다.</strong></p>

<h4 id="작동할-수도-있다">작동할 수도 있다??</h4>
<p>여기서 주석문을 수정했는데 적용이 안된다면 나와 같은 경우일 수도 있다.</p>

<p>우선 나는 Apache를 Homebrew를 통해 설치할 때 경로가 다르게 설정된 것 같다. 위의 코드로 httpd.conf 파일에 이동하면 아무것도 없었기 때문이다.</p>

<p>이럴 때는</p>
<blockquote>
  <p>which httpd</p>
</blockquote>

<p>명령어를 통해 Apache 파일이 정확히 어디에있는지 확인한 후</p>

<blockquote>
  <p>sudo nano /opt/homebrew/etc/httpd/httpd.conf</p>
</blockquote>

<p>위 코드를 통해 다시 적용하고 서버를 재시작하면 작동될 것이다.</p>

<h3 id="️-port-설정">⚠️ Port 설정</h3>

<p>만약 <code class="language-plaintext highlighter-rouge">http://localhost</code>를 입력했는데 안되고, <code class="language-plaintext highlighter-rouge">http://localhost:8080</code>이 된다면?</p>

<p>-&gt; Apache conf 파일로 이동해서 Listen을 검색하면 Port 번호가 8080으로 되어있을 것이다. 이를 <code class="language-plaintext highlighter-rouge">80 (기본포트)</code>로 변경해주면 된다.</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/46421195-4930-4d18-9962-4ce000873a55/image.png" alt="" /></p>

<h3 id="3️⃣-웹-페이지-구축">3️⃣ 웹 페이지 구축</h3>

<ul>
  <li>나는 설치 경로가 다르므로 앞으로 나의 경로에 맞게 작성함</li>
</ul>

<p>아래 명령어를 통해 디렉토리로 이동하면 <code class="language-plaintext highlighter-rouge">index.html</code> 파일이 있을 것이다.</p>

<blockquote>
  <p>cd /opt/homebrew/var/www</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">index.html</code>파일은 내가 보여줄 기본 홈페이지 화면이다. 이를 vscode 를 통해 간단한 구문을 적어보도록 하겠다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1.0"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>My Web Page<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Welcome to My Apache Web Server!<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;p&gt;</span>This is my first webpage on Apache.<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>
<p>이를 적용하면 바뀐 모습을 볼 수 있다.</p>

<p><img src="https://velog.velcdn.com/images/ghkdehs/post/45bb71ed-d9f0-41d7-bc0f-24ac536c4ae9/image.png" alt="" /></p>

<p>여기까지 기초적인 웹 서버 자체를 구축했다. 
다음부터 웹 서버 운영을 다뤄보려 한다.</p>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Linux" /><category term="Infra" /><category term="Linux" /><summary type="html"><![CDATA[리눅스 웹 서버 구축 오픈 소스 웹 서버 소프트웨어인 Apache 를 사용해서 웹 서버를 구축해보려 한다.]]></summary></entry><entry><title type="html">「 Linux 」 리눅스?</title><link href="http://localhost:4000/linux/Linux-outline/" rel="alternate" type="text/html" title="「 Linux 」 리눅스?" /><published>2025-02-20T01:00:00+09:00</published><updated>2025-03-22T14:30:00+09:00</updated><id>http://localhost:4000/linux/Linux-outline</id><content type="html" xml:base="http://localhost:4000/linux/Linux-outline/"><![CDATA[<h2 id="linux">Linux?</h2>
<!--more-->

<ul>
  <li>Unix 기반의 오픈소스 OS</li>
  <li>윈도우, MacOS와 달리 <strong>무료</strong>이며, <strong>오픈소스</strong>이기 때문에 자유롭게 수정과 배포가 가능함</li>
</ul>

<p><strong>운영체제(OS)</strong>: <strong>하드웨어</strong>를 프로그램을 통해 쉽게 사용할 수 있도록 해주는 <strong>소프트웨어</strong>이다.</p>

<p>여기서 설명하는 리눅스는 <strong>완전한 리눅스</strong>를 뜻함 이는 후술하겠음</p>
<h2 id="-linux-기본구조">💻 Linux 기본구조</h2>
<p>크게 4가지로 나뉜다.</p>

<h3 id="1-커널kernel">1. 커널(Kernel)</h3>
<p>운영체제의 핵심으로 <strong>하드웨어와 소프트웨어를 연결하는 역할</strong>을 함.</p>

<h3 id="커널의-역할">커널의 역할</h3>

<table>
  <thead>
    <tr>
      <th>역할</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>프로세스 관리</strong></td>
      <td>실행 중인 프로그램(프로세스)을 생성, 실행, 종료 및 스케줄링</td>
    </tr>
    <tr>
      <td><strong>메모리 관리</strong></td>
      <td>RAM 및 가상 메모리를 효율적으로 할당 및 해제</td>
    </tr>
    <tr>
      <td><strong>파일 시스템 관리</strong></td>
      <td>파일과 디렉토리, 저장장치를 관리</td>
    </tr>
    <tr>
      <td><strong>장치 관리</strong></td>
      <td>CPU, 디스크, 네트워크 장치 등 하드웨어를 제어</td>
    </tr>
    <tr>
      <td><strong>네트워크 관리</strong></td>
      <td>네트워크 인터페이스 및 데이터 통신을 담당</td>
    </tr>
  </tbody>
</table>

<h3 id="정리">정리</h3>
<p>✅ <strong>커널은 OS의 핵심이며, 프로세스, 메모리, 파일, 장치, 네트워크 관리 담당</strong><br />
✅ <strong>운영체제의 성능과 안정성에 중요한 역할을 함</strong></p>

<hr />
<h3 id="2-쉘shell">2. 쉘(Shell)</h3>
<p>사용자가 운영체제(커널)와 소통할 수 있도록 <strong>명령어를 입력받고 실행하는 인터페이스</strong>.<br />
쉽게 말해, <strong>사용자의 명령을 해석해서 커널에 전달하는 번역기 역할</strong>을 함.</p>

<h3 id="쉘의-역할">쉘의 역할</h3>

<table>
  <thead>
    <tr>
      <th>역할</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>명령어 해석</strong></td>
      <td>사용자가 입력한 명령어를 해석하여 커널에 전달</td>
    </tr>
    <tr>
      <td><strong>프로그램 실행</strong></td>
      <td>사용자가 입력한 명령어 또는 스크립트를 실행</td>
    </tr>
    <tr>
      <td><strong>파일 &amp; 디렉토리 관리</strong></td>
      <td>파일 생성, 삭제, 이동 등의 작업 수행</td>
    </tr>
    <tr>
      <td><strong>프로세스 제어</strong></td>
      <td>실행 중인 프로세스를 백그라운드/포그라운드 전환 및 종료</td>
    </tr>
    <tr>
      <td><strong>스크립트 실행</strong></td>
      <td>반복적인 작업을 자동화할 수 있는 쉘 스크립트 지원</td>
    </tr>
  </tbody>
</table>

<h3 id="쉘의-종류">쉘의 종류</h3>

<table>
  <thead>
    <tr>
      <th>쉘 종류</th>
      <th>특징</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Bash (Bourne Again Shell)</strong></td>
      <td>가장 많이 사용되는 기본 쉘 (리눅스 기본)</td>
    </tr>
    <tr>
      <td><strong>Sh (Bourne Shell)</strong></td>
      <td>Bash의 원조, 가벼운 쉘</td>
    </tr>
    <tr>
      <td><strong>Zsh (Z Shell)</strong></td>
      <td>강력한 자동 완성 &amp; 플러그인 지원</td>
    </tr>
  </tbody>
</table>

<p>📌 <strong>리눅스 기본 쉘은 Bash</strong>이며, 필요에 따라 다른 쉘로 변경 가능.</p>

<h2 id="정리-1">정리</h2>
<p>✅ <strong>쉘은 사용자가 커널과 소통할 수 있도록 해주는 인터페이스</strong><br />
✅ <strong>명령어 실행, 파일 관리, 프로세스 제어, 스크립트 자동화 기능을 제공</strong><br />
✅ <strong>Bash가 기본이지만 Zsh, Fish 같은 다양한 쉘도 사용 가능</strong></p>

<hr />

<h3 id="3-하드웨어hardware">3. 하드웨어(Hardware)</h3>

<p><strong>컴퓨터구조</strong>에서 더욱 자세히 다룸</p>

<table>
  <thead>
    <tr>
      <th>하드웨어</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>CPU (Central Processing Unit)</strong></td>
      <td>컴퓨터의 두뇌, 모든 계산과 명령을 처리함</td>
    </tr>
    <tr>
      <td><strong>메모리 (RAM)</strong></td>
      <td>데이터를 일시적으로 저장, 프로그램 실행에 필요한 데이터를 빠르게 읽고 씀</td>
    </tr>
    <tr>
      <td><strong>저장 장치 (Hard Disk, SSD)</strong></td>
      <td>데이터를 영구적으로 저장하는 장치, 컴퓨터가 꺼져도 데이터가 유지됨</td>
    </tr>
    <tr>
      <td><strong>입출력 장치 (Input/Output Devices)</strong></td>
      <td>사용자가 컴퓨터와 상호작용할 수 있게 돕는 장치, 예: 키보드, 마우스, 모니터 등</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="4-프로그램program">4. 프로그램(Program)</h3>

<p><strong>프로그램</strong>은 <strong>하드웨어에서 실행되는 소프트웨어</strong>로, 특정 작업을 수행하거나 시스템을 제어하는 코드들로 구성</p>

<table>
  <thead>
    <tr>
      <th>프로그램 종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>시스템 소프트웨어</strong></td>
      <td>하드웨어와 사용자 간 상호작용을 도와주는 소프트웨어, 예: 운영체제(OS)</td>
    </tr>
    <tr>
      <td><strong>응용 소프트웨어</strong></td>
      <td>특정 작업을 수행하는 소프트웨어, 예: 웹 브라우저, 게임, 워드 프로세서 등</td>
    </tr>
  </tbody>
</table>

<hr />
<h2 id="-gnu-프로젝트와-리눅스-관계">💻 GNU 프로젝트와 리눅스 관계</h2>
<p>리눅스라고 했을 때 우리가 보통 리눅스 OS라고 부르는 것은 사실 리눅스 커널과 그 위에 추가적인 소프트웨어들, 즉 툴들이 결합된 운영체제를 의미함</p>

<p>즉,</p>
<ul>
  <li><strong>리눅스 커널</strong>만으로는 운영체제가 아님 → <strong>GNU 프로젝트의 툴</strong>과 결합해서 완전한 OS가 됨.</li>
  <li>그래서 <strong>GNU/Linux</strong>라고도 부름.<br />
(예: Ubuntu는 GNU 툴 + 리눅스 커널을 포함한 배포판)
—
    <h2 id="-리눅스-배포판-linux-distribution">💻 리눅스 배포판 (Linux Distribution)</h2>
    <p>위에서 설명했다시피 리눅스는 커널만으로 동작하지 않기 때문에 
<strong>리눅스 커널 + GNU 프로젝트(또는 툴)</strong> 을 조합해서 만든 <strong>배포판</strong>을 통해 <strong>완전한 리눅스</strong>를 사용할 수 있다.</p>
  </li>
</ul>

<h3 id="대표적인-배포판">대표적인 배포판</h3>
<p>| 배포판  | 특징 |
|———|—————-|
| <strong>Ubuntu</strong>  | 초보자 친화적, 데스크탑 &amp; 서버용으로 인기 |
| <strong>CentOS</strong>  | 안정성이 뛰어나 서버용으로 많이 사용됨 (RHEL 기반) |
| <strong>Debian</strong>  | 보안과 안정성이 뛰어나며 다양한 파생판이 존재 |
| <strong>Fedora</strong>  | 최신 기술 반영이 빠르며 Red Hat 지원 |
| <strong>Arch Linux</strong>  | 최소한의 기본 구성, 사용자가 직접 커스터마이징 |
—</p>

<h2 id="-cli-vs-gui">💻 CLI vs GUI</h2>
<p>| 인터페이스 | 설명 |
|————|————————————————–|
| <strong>CLI (Command Line Interface)</strong> | 명령어 기반, 터미널 사용 (서버 관리에 최적화) |
| <strong>GUI (Graphical User Interface)</strong> | 그래픽 환경 제공 (데스크탑 사용에 적합) |</p>
<ul>
  <li>리눅스는 기본적으로 CLI 중심이지만, GUI 환경도 사용 가능.</li>
  <li><strong>서버 운영 = CLI</strong>, <strong>일반 사용자 = GUI</strong> 선택 가능</li>
</ul>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Linux" /><category term="Linux" /><summary type="html"><![CDATA[Linux?]]></summary></entry><entry><title type="html">「 Linux 」 리눅스 명령어</title><link href="http://localhost:4000/linux/Linux-Command/" rel="alternate" type="text/html" title="「 Linux 」 리눅스 명령어" /><published>2025-02-20T01:00:00+09:00</published><updated>2025-02-20T01:00:00+09:00</updated><id>http://localhost:4000/linux/Linux-Command</id><content type="html" xml:base="http://localhost:4000/linux/Linux-Command/"><![CDATA[<h2 id="linux-기본-명령어">Linux 기본 명령어</h2>

<!--more-->

<h3 id="️-1-파일-및-디렉토리-관리">⚙️ 1. 파일 및 디렉토리 관리</h3>
<h3 id="ls--디렉토리-내용-목록-보기"><code class="language-plaintext highlighter-rouge">ls</code> : 디렉토리 내용 목록 보기</h3>
<p>현재 디렉토리 안에 있는 파일이나 폴더들을 보여줌</p>

<p><code class="language-plaintext highlighter-rouge">ls</code> : 현재 디렉토리의 파일과 폴더 목록을 나열
<code class="language-plaintext highlighter-rouge">ls -l</code> : 파일의 세부 정보까지 나열
<code class="language-plaintext highlighter-rouge">ls -a</code> : 숨겨진 파일까지 모두 나열
<code class="language-plaintext highlighter-rouge">ls -lh</code> : 사람이 읽기 좋은 형식으로 파일 크기 표시</p>

<h3 id="cd--디렉토리-이동"><code class="language-plaintext highlighter-rouge">cd</code> : 디렉토리 이동</h3>
<p>현재 작업 중인 디렉토리를 바꾸는 명령어</p>

<p><code class="language-plaintext highlighter-rouge">cd /home/user</code> : 지정된 경로로 이동
<code class="language-plaintext highlighter-rouge">cd ..</code> : 상위 디렉토리로 이동
<code class="language-plaintext highlighter-rouge">cd ~</code> : 홈 디렉토리로 이동
<code class="language-plaintext highlighter-rouge">cd</code> : 아무 옵션 없이 입력하면 기본적으로 홈 디렉토리로 이동</p>

<h3 id="pwd--현재-작업-중인-디렉토리-경로-출력"><code class="language-plaintext highlighter-rouge">pwd</code> : 현재 작업 중인 디렉토리 경로 출력</h3>
<p>pwd는 현재 내가 있는 디렉토리의 경로를 알려주는 명령어</p>

<p><code class="language-plaintext highlighter-rouge">pwd</code> : 현재 작업 중인 디렉토리 경로 출력 (예: /home/user)</p>

<h3 id="cp--파일-복사"><code class="language-plaintext highlighter-rouge">cp</code> : 파일 복사</h3>
<p>cp는 파일이나 디렉토리를 다른 위치로 복사하는 명령어</p>

<p><code class="language-plaintext highlighter-rouge">-r</code> : 디렉토리 복사 시 필요 (디렉토리 안의 파일과 하위 디렉토리까지 복사)
<code class="language-plaintext highlighter-rouge">-i</code> : 덮어쓰기 전에 사용자에게 확인을 요구</p>

<p><code class="language-plaintext highlighter-rouge">cp file1.txt /backup/</code> : file1.txt를 /backup/ 디렉토리로 복사
<code class="language-plaintext highlighter-rouge">cp -r /home/user /backup/</code>: /home/user 디렉토리와 그 안의 모든 파일을 /backup/로 복사</p>

<h3 id="mv--파일디렉토리-이동-또는-이름-변경"><code class="language-plaintext highlighter-rouge">mv</code> : 파일/디렉토리 이동 또는 이름 변경</h3>
<p>mv는 파일이나 디렉토리를 이동하거나 이름을 변경하는 명령어</p>

<p><code class="language-plaintext highlighter-rouge">-i</code> : 덮어쓰기 전에 사용자에게 확인을 요구</p>

<p><code class="language-plaintext highlighter-rouge">mv file1.txt /backup/</code> : file1.txt를 /backup/ 디렉토리로 이동
<code class="language-plaintext highlighter-rouge">mv oldname.txt newname.txt</code> : oldname.txt 파일의 이름을 newname.txt로 변경</p>

<h3 id="rm--파일-삭제"><code class="language-plaintext highlighter-rouge">rm</code> : 파일 삭제</h3>
<p>rm은 파일을 삭제하는 명령어</p>

<p><code class="language-plaintext highlighter-rouge">-r</code> : 디렉토리와 그 안의 파일을 재귀적으로 삭제
<code class="language-plaintext highlighter-rouge">-f</code> : 강제로 삭제 (파일이 없더라도 경고 없이 삭제)</p>

<p><code class="language-plaintext highlighter-rouge">rm file1.txt</code> : file1.txt 파일 삭제
<code class="language-plaintext highlighter-rouge">rm -r directory/</code> : directory 디렉토리와 그 안의 모든 파일 삭제
<code class="language-plaintext highlighter-rouge">rm -f file1.txt</code> : 경고 없이 강제로 file1.txt 삭제</p>

<h3 id="mkdir--디렉토리-생성"><code class="language-plaintext highlighter-rouge">mkdir</code> : 디렉토리 생성</h3>
<p>새로운 디렉토리를 생성하는 명령어</p>

<p><code class="language-plaintext highlighter-rouge">-p</code> : 부모 디렉토리까지 함께 생성 ( 경로에 부모 디렉토리가 없으면 부모 디렉토리까지 한 번에 생성 )</p>

<p><code class="language-plaintext highlighter-rouge">mkdir my_folder</code> : my_folder라는 새 디렉토리 생성
<code class="language-plaintext highlighter-rouge">mkdir -p projects/webapp/assets</code> : projects/webapp/assets 경로에 필요한 모든 디렉토리 생성</p>

<h3 id="touch--빈-파일-생성-또는-수정-시간-갱신"><code class="language-plaintext highlighter-rouge">touch</code> : 빈 파일 생성 또는 수정 시간 갱신</h3>
<p>새로운 파일을 생성하거나 기존 파일의 수정 시간을 갱신하는 명령어</p>

<p><code class="language-plaintext highlighter-rouge">touch myfile.txt</code> : myfile.txt라는 빈 파일을 생성하거나 기존 파일의 수정 시간을 갱신</p>

<h3 id="rmdir--빈-디렉토리-삭제"><code class="language-plaintext highlighter-rouge">rmdir</code> : 빈 디렉토리 삭제</h3>
<p>비어 있는 디렉토리만 삭제할 수 있는 명령어</p>

<p><code class="language-plaintext highlighter-rouge">-p</code> : 부모 디렉토리까지 삭제
빈 디렉토리를 삭제하면서, 그 부모 디렉토리가 비어 있으면 부모 디렉토리까지 삭제</p>

<p><code class="language-plaintext highlighter-rouge">rmdir my_folder</code> : my_folder라는 빈 디렉토리 삭제
<code class="language-plaintext highlighter-rouge">rmdir -p projects/webapp/assets</code> : assets, webapp, projects가 모두 비어 있으면 한 번에 부모 디렉토리까지 삭제</p>

<hr />

<h2 id="-2파일-내용-조회">🔍 2.파일 내용 조회</h2>

<h3 id="cat--파일-내용-출력"><code class="language-plaintext highlighter-rouge">cat</code> : 파일 내용 출력</h3>
<ul>
  <li>파일의 내용을 전체 출력</li>
  <li>내용이 길면 한 번에 다 나와서 화면을 넘기기 어려울 수 있음</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">cat myfile.txt</code> : myfile.txt 파일 내용을 화면에 한 번에 출력</p>

<p><img src="스크린샷 2025-02-17 14.44.08.png" alt="alt text" /></p>

<h3 id="more--파일-내용-한-페이지씩-출력"><code class="language-plaintext highlighter-rouge">more</code> : 파일 내용 한 페이지씩 출력</h3>

<ul>
  <li>파일을 한 페이지씩, 화면을 넘겨서 볼 수 있는 명령어</li>
  <li>파일 내용이 길 때 유용</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">more myfile.txt</code> : myfile.txt 파일을 한 페이지씩 출력하면서 볼 수 있음</p>

<h3 id="less--파일-내용-스크롤하며-출력"><code class="language-plaintext highlighter-rouge">less</code> : 파일 내용 스크롤하며 출력</h3>
<ul>
  <li>more와 비슷하지만 더 많은 기능 제공</li>
  <li>less는 양 방향 스크롤이 가능 (위로, 아래로)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">less myfile.txt</code> : myfile.txt 파일을 스크롤하며 내용 확인, q를 눌러 종료</p>

<h3 id="head--파일의-처음-10줄-출력"><code class="language-plaintext highlighter-rouge">head</code> : 파일의 처음 10줄 출력</h3>
<ul>
  <li>파일의 앞부분 10줄만 출력</li>
  <li>출력할 줄 수는 <code class="language-plaintext highlighter-rouge">-n</code> 옵션으로 변경 가능
<code class="language-plaintext highlighter-rouge">head myfile.txt</code> :  myfile.txt 파일의 처음 10줄을 출력
<code class="language-plaintext highlighter-rouge">head -n 20 myfile.txt</code> : myfile.txt 파일의 처음 20줄을 출력</li>
</ul>

<h3 id="tail--파일의-마지막-10줄-출력"><code class="language-plaintext highlighter-rouge">tail</code> : 파일의 마지막 10줄 출력</h3>
<ul>
  <li>파일의 뒷부분 10줄만 출력</li>
  <li>출력할 줄 수는 <code class="language-plaintext highlighter-rouge">-n</code> 옵션으로 변경 가능</li>
  <li><code class="language-plaintext highlighter-rouge">-f</code> 옵션을 사용하면 파일 내용의 변화를 실시간으로 추적 가능
<code class="language-plaintext highlighter-rouge">tail myfile.txt</code> : myfile.txt 파일의 마지막 10줄을 출력
<code class="language-plaintext highlighter-rouge">tail -n 20 myfile.txt</code> : myfile.txt 파일의 마지막 20줄을 출력
<code class="language-plaintext highlighter-rouge">tail -f myfile.txt</code> : 파일이 업데이트될 때마다 마지막 줄을 계속 출력 (로그 파일 등 실시간 모니터링 시 유용)</li>
</ul>

<h3 id="grep--파일에서-특정-문자열-검색"><code class="language-plaintext highlighter-rouge">grep</code> : 파일에서 특정 문자열 검색</h3>
<ul>
  <li>파일 내에서 특정 문자열을 검색하고 해당 부분을 출력</li>
  <li>대소문자 구분 없이 검색하려면 <code class="language-plaintext highlighter-rouge">-i</code> 옵션 사용</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">grep "hello" myfile.txt</code> : myfile.txt 파일에서 hello라는 문자열을 찾고 출력
<code class="language-plaintext highlighter-rouge">grep -i "hello" myfile.txt</code> : hello를 대소문자 구분 없이 검색
<code class="language-plaintext highlighter-rouge">grep -r "hello"</code> : 현재 디렉토리와 하위 디렉토리에서 hello 검색</p>

<hr />
<h2 id="-3-파일-및-디렉토리-권한">🔒 3. 파일 및 디렉토리 권한</h2>

<h3 id="chmod--파일-권한-변경"><code class="language-plaintext highlighter-rouge">chmod</code> : 파일 권한 변경</h3>

<ul>
  <li>chmod 명령어는 파일이나 디렉토리의 읽기/쓰기/실행 권한을 변경할 때 사용</li>
  <li>권한은 숫자나 기호로 설정할 수 있음</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">권한의 숫자 값</code></p>

<p><code class="language-plaintext highlighter-rouge">r</code> (읽기): 4</p>

<p><code class="language-plaintext highlighter-rouge">w</code> (쓰기): 2</p>

<p><code class="language-plaintext highlighter-rouge">x</code> (실행): 1</p>

<p>각 권한을 숫자값으로 합쳐서 설정</p>

<p>예시 (숫자로 설정):</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">chmod 755 myfile.txt</code>
    <ul>
      <li>소유자에게 읽기/쓰기/실행 권한, 그룹과 다른 사용자에게 읽기/실행 권한을 부여</li>
      <li>7 = rwx, 5 = r-x, 5 = r-x</li>
    </ul>
  </li>
</ul>

<p>예시 (기호로 설정):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">chmod u+x myfile.txt</code>
    <ul>
      <li>소유자(u)에게 실행 권한 추가</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">chmod go-r myfile.txt</code>
    <ul>
      <li>그룹(g)과 다른 사용자(o)에서 읽기 권한 제거</li>
    </ul>
  </li>
</ul>

<h3 id="chown--파일-소유자와-그룹-변경"><code class="language-plaintext highlighter-rouge">chown</code> : 파일 소유자와 그룹 변경</h3>
<ul>
  <li>chown 명령어는 파일이나 디렉토리의 소유자와 그룹을 변경하는 명령어</li>
  <li>기본적으로 chown <소유자>:<그룹> <파일> 형태로 사용</파일></그룹></소유자></li>
  <li>
    <p>소유자와 그룹을 바꾸지 않으려면 생략 가능</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">chown user:group myfile.txt</code>
    <ul>
      <li>myfile.txt의 소유자를 user, 그룹을 group으로 변경</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">chown user myfile.txt</code>
    <ul>
      <li>myfile.txt의 소유자만 user로 변경</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">chown :group myfile.txt</code>
    <ul>
      <li>myfile.txt의 그룹만 group으로 변경</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="-이-외의-추가적인-명령어">💻 이 외의 추가적인 명령어</h2>

<h3 id="echo--텍스트나-변수-값을-출력할-때-사용"><code class="language-plaintext highlighter-rouge">echo</code> : 텍스트나 변수 값을 출력할 때 사용</h3>

<p><code class="language-plaintext highlighter-rouge">echo Hello, World!</code> : 화면에 “Hello, World!” 출력</p>

<p><code class="language-plaintext highlighter-rouge">echo $HOME</code> : 현재 사용자의 홈 디렉토리 경로 출력</p>

<p><code class="language-plaintext highlighter-rouge">echo "My name is $USER"</code> : 변수 사용 (현재 사용자 이름 출력)</p>

<h3 id="sudo--관리자-권한으로-명령어를-실행할-때-사용"><code class="language-plaintext highlighter-rouge">sudo</code> : 관리자 권한으로 명령어를 실행할 때 사용</h3>
<ul>
  <li>sudo는 “SuperUser Do”의 줄임말로, 일반 사용자가 관리자 권한을 얻어 명령어를 실행할 수 있게 함.</li>
  <li>예를 들어 시스템 파일을 수정하거나, 패키지를 설치할 때 필요</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">sudo apt-get update</code> : 시스템 패키지 목록을 업데이트 (Ubuntu 기준)</p>

<p><code class="language-plaintext highlighter-rouge">sudo rm -rf /</code> : 주의! 시스템을 파괴할 수 있음 (루트 디렉토리 삭제)</p>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Linux" /><category term="Linux" /><summary type="html"><![CDATA[Linux 기본 명령어]]></summary></entry><entry><title type="html">SpringBoot 프로젝트 생성</title><link href="http://localhost:4000/springboot/spring/" rel="alternate" type="text/html" title="SpringBoot 프로젝트 생성" /><published>2025-01-19T01:00:00+09:00</published><updated>2025-03-22T14:30:00+09:00</updated><id>http://localhost:4000/springboot/spring</id><content type="html" xml:base="http://localhost:4000/springboot/spring/"><![CDATA[<p><img src="https://velog.velcdn.com/images/ukja2/post/f5a31409-56dc-4b07-bbbe-490beb314b9e/image.png" alt="" /></p>

<p>스프링부트 프로젝트 생성시 참고사항
<!--more--></p>

<h3 id="project-metadata">Project Metadata</h3>
<ul>
  <li>Group : 프로젝트가 속한 조직이나 회사 이름을 나타내며, Group값은 기본적으로 Java 프로젝트의 최상위 패키지 이름으로 사용됨</li>
  <li>Artifact : 프로젝트의 이름</li>
  <li>
    <p>Packaging 
  <img src="https://velog.velcdn.com/images/ukja2/post/1e1f9960-567f-49ae-8354-bfec19829826/image.png" alt="" />
언제 JAR과 WAR을 선택할까?
‣ JAR:
Spring Boot의 내장 서버를 활용해 간단히 실행 가능한 애플리케이션을 만들고 싶을 때.
마이크로서비스 아키텍처를 사용할 때.
‣ WAR:
기존 서블릿 컨테이너(Tomcat, JBoss 등)에 배포해야 할 때.
레거시 시스템과의 호환성이 필요할 때.</p>
  </li>
  <li>Java : JDK 버전에 맞게 선택</li>
</ul>

<h3 id="dependencies">Dependencies</h3>
<p>스프링 프레임워크를 사용할 때 특정 기능을 구현하기 위해 다양한 라이브러리를 추가해야 되는데, 이를 직접 설정하는 대신 이니셜라이저가 제공하는 옵션에서 선택할 수 있다.</p>

<p>예를 들어</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Spring Web</code> : 웹 애플리케이션 개발을 위한 종속성 (Spring MVC 포함).</li>
  <li><code class="language-plaintext highlighter-rouge">Spring Boot DevTools</code> : 개발 편의를 위한 도구 (자동 리로드 기능 등).</li>
  <li><code class="language-plaintext highlighter-rouge">Spring Data JPA</code> : 데이터베이스 연동을 쉽게 해주는 라이브러리.</li>
  <li><code class="language-plaintext highlighter-rouge">Spring Security</code> : 인증과 권한 관리를 위한 라이브러리.</li>
  <li><code class="language-plaintext highlighter-rouge">Thymeleaf</code> : HTML 템플릿 엔진.</li>
</ul>

<p>종속성의 역할</p>

<ul>
  <li>기능 추가: 필요한 라이브러리를 자동으로 프로젝트에 포함시켜 줌.</li>
  <li>간편한 설정: 각 라이브러리에 맞는 기본 설정을 자동으로 제공.</li>
  <li>의존성 관리: 관련된 라이브러리 버전을 스프링 부트에 맞게 맞춰줌.</li>
</ul>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="SpringBoot" /><category term="SpringBoot" /><category term="Java" /><summary type="html"><![CDATA[스프링부트 프로젝트 생성시 참고사항]]></summary></entry><entry><title type="html">Jekyll theme를 이용한 블로그 개설과 오류 해결과정</title><link href="http://localhost:4000/jekyll/Jektll-theme-blog/" rel="alternate" type="text/html" title="Jekyll theme를 이용한 블로그 개설과 오류 해결과정" /><published>2024-09-09T00:19:00+09:00</published><updated>2024-09-09T00:19:00+09:00</updated><id>http://localhost:4000/jekyll/Jektll-theme-blog</id><content type="html" xml:base="http://localhost:4000/jekyll/Jektll-theme-blog/"><![CDATA[<p>블로그를 개설 중 발생한 자잘한 오류 해결과 과정
<!--more--></p>

<hr />
<h3 id="1-githubio-repository-생성">1. Github.io repository 생성</h3>
<ol>
  <li>
    <p>우선 Github에서 ` {사용자이름}.github.io` 형식의 repo를 생성했다.
<img src="https://velog.velcdn.com/images/ukja2/post/5ef7660a-842c-45e8-944c-b82ddfa30020/image.png" alt="" /></p>
  </li>
  <li>
    <p>저렇게 생성된 repo를 나의 로컬저장소에 clone한다.
** 이때 clone할 repo의 경로에 한국어가 있으면 추후 오류가 발생할 확률이 있기 때문에 영어로 된 경로에 clone할 것을 권장한다. **</p>

    <p>나는 C 저장소에 따로 <code class="language-plaintext highlighter-rouge">Ukja2Blog</code> 라는 폴더를 생성 후 해당 폴더 내부에 clone했다.
<img src="https://velog.velcdn.com/images/ukja2/post/48e553e3-3fbe-4deb-bc02-da92954d3428/image.png" alt="" /></p>
  </li>
</ol>

<h3 id="2-ruby-및-jekyll-설치">2. Ruby 및 Jekyll 설치</h3>

<ol>
  <li>Ruby를 설치해준다.
<img src="https://velog.velcdn.com/images/ukja2/post/626a70de-82d4-4e92-8121-3415f92a3108/image.png" alt="" />
여기서 <code class="language-plaintext highlighter-rouge">DEVKIT</code>가 포함된 버전으로 설치해주고, 설치버전은 오른 쪽 표시처럼  3.3.X 버전이 안정화된 버전임을 뜻하므로 여기에 해당되는 버전,bit를 설치해주면 된다.</li>
</ol>

<p>설치 후 <code class="language-plaintext highlighter-rouge">cmd</code> 창을 켜서 아래와 설치버전이 나오면 성공적으로 설치됐음을 의미한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby -v (입력)
ruby 3.3.5 (2024-09-03 revision ef084cc8f4) [x64-mingw-ucrt] (출력)
</code></pre></div></div>
<ol>
  <li>Jekyll과 bundler 설치
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gem install jekyll
$ gem install bundler
</code></pre></div>    </div>
  </li>
</ol>

<p>Jekyll과 bundler를 설치하는 이유를 쉽게 설명하자면 Ruby내에서 <code class="language-plaintext highlighter-rouge">bundler</code>를 통해 <code class="language-plaintext highlighter-rouge">Jekyll</code>을 실행하고 <code class="language-plaintext highlighter-rouge">Jekyll</code>을 사용해서 우리가 원하는 블로그를 만들 수 있다.</p>

<p>bundler에 대한 설명은 아래와 같다.
** “bundler는 Ruby 프로젝트에 필요한 Gem들의 버전을 추적하고 설치해서 일관된 환경을 제공한다.”**
즉 다른 버전의 프로젝트들을 실행할때 원활하게 작동할 수 있도록 해주며, 전체적으로 Ruby의 쾌적한 사용환경을 제공해주는 것 같다.</p>

<p>설치를 완료 했다면 아래와 같이 입력 후 설치 확인을 해준다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jekyll -v (입력)
jekyll 4.3.3 (출력)

bundler -v (입력)
Bundler version 2.5.18 (출력)
</code></pre></div></div>

<h3 id="3-jekyll-theme-파일-넣기">3. Jekyll Theme 파일 넣기</h3>

<ol>
  <li>
    <p>원하는 Jekyll Theme를 아래 사이트에서 고른다.
** http://jekyllthemes.org/ **</p>
  </li>
  <li>
    <p>적용하고 싶은 테마의 파일을 압축해제 후 자신의 <code class="language-plaintext highlighter-rouge">github.io repository</code>를 clone한 폴더 내부로 옮겨준다.</p>
  </li>
  <li>테마를 폴더로 옮겨주었다면 <code class="language-plaintext highlighter-rouge">초기화 작업을 해주는 코드를 작성해야 되는데</code> 여기서 한 가지 문제가 발생한다.
해당 코드인 <code class="language-plaintext highlighter-rouge">$ bash tools/init.sh</code>는 Linux 환경에서 사용할 수 있기 때문에 Windows   환경에서는 수동으로 초기화 하는 방법은 선택해야 된다. ** ( 처음부터 WSL을 활용해서 작업하는 것을 추천 ) **
    <blockquote>
      <p>https://devpro.kr/posts/Github-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-(3)/
Linux 환경에서 작업할 수 없다면 위 링크를 통해 따라하도록 하자
!! 이렇게 했을 시 환경에 따라 오류가 발생할 수도 있다. 이는 후술함 !!</p>
    </blockquote>
  </li>
  <li>초기화 작업을 해주었다면 <code class="language-plaintext highlighter-rouge">git bash</code> 로 <code class="language-plaintext highlighter-rouge">bundler install</code> 을 입력하면 정상적으로 테마적용이 완료될 것이다.</li>
</ol>

<p>이후 <code class="language-plaintext highlighter-rouge">config.yml</code> 과  <code class="language-plaintext highlighter-rouge">assets</code> 폴더 내부의 css 파일을 수정하는 등 자신의 취향에 맞게 블로그를 꾸밀 수 있다.</p>

<p>모든 설정이 끝나면 아래 코드를 git bash에 입력하면</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ bundle exec jekyll serve
</code></pre></div></div>
<p><img src="https://velog.velcdn.com/images/ukja2/post/c203c8b4-d424-4609-872c-8a7b8a79ef02/image.png" alt="" /></p>

<p>노란색으로 표시한 Server address의 호스팅 주소를 브라우저에 입력하면 자신만의 블로그가 나타난다.
<img src="https://velog.velcdn.com/images/ukja2/post/6a8311f1-8fef-4a89-9cd2-54234a816c80/image.png" alt="" /></p>

<hr />
<h2 id="오류발생과-해결">오류발생과 해결</h2>

<h3 id="1-ruby와-jekyll을-처음-설치하고-테마를-적용하기-전-jekyll-new-을-통해-첫-프로젝트-생성후-bundler-install-실행-시-발생한-오류">1. Ruby와 jekyll을 처음 설치하고 테마를 적용하기 전 <code class="language-plaintext highlighter-rouge">jekyll new ./</code>을 통해 첫 프로젝트 생성후 <code class="language-plaintext highlighter-rouge">bundler install</code> 실행 시 발생한 오류</h3>
<blockquote>
  <p>An error occurred while installing wdm (0.1.1), and Bundler cannot continue.</p>
</blockquote>

<p>위 오류에 대한 해결방법은 나의 벨로그에 작성해 놓았다.</p>

<h3 id="2-bundle-exec로-블로그-실행-시-git-bash에-나타난-오류">2. bundle exec로 블로그 실행 시 git bash에 나타난 오류</h3>
<blockquote>
  <p>assets/js/dist/*.min.js Not Found</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">~~.min.js</code> 를 찾을 수 없다는 뜻인데
Jekyll Theme는 JavaScript 기반이다 보니 다양한 기능을 적용시키기 위해서는 Node.js가 필요하다. ex) 다크모드, 라이트모드, 검색창기능</p>

<p>이를 해결하기 위해 수많은 검색을 하다가 해결 방법을 찾아냈다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">tools/init.sh</code> 은 Linux 환경의 node.js를 통해서 사용할 수 있다.</li>
  <li>위 작업을 해주면 <code class="language-plaintext highlighter-rouge">assets/js/dist/*.min.js</code> 자동으로 생성되는 구조이다. 
아마 내 생각엔 <code class="language-plaintext highlighter-rouge">tools/init.sh</code> 스크립트 내부에 build를 해주는 기능이 포함된 것 같다.</li>
  <li>나는 <code class="language-plaintext highlighter-rouge">tools/init.sh</code> 대신 수동으로 초기화 작업을 했기 때문에  <code class="language-plaintext highlighter-rouge">*.min.js</code>가 생성될 수 없었다.</li>
</ol>

<p>그래서 나는 없는 <code class="language-plaintext highlighter-rouge">*.min.js</code> 파일을 Node.js를 통해 build하는 방법을 사용했다.</p>

<ol>
  <li>우선 Node.js를 설치</li>
  <li>git bash로 <code class="language-plaintext highlighter-rouge">npm install</code> , <code class="language-plaintext highlighter-rouge">npm run build</code>를 입력해주면 위의 오류가 사라지는 것을 확인할 수 있다. <em>npm install을 하는 과정에서 아래와 같은 오류가 발생했다. 이와 별개로 위 작업이 정상적으로 진행된다면 오류는 해결된다.</em></li>
</ol>

<h3 id="3-nodejs를-설치하고-npm-install을-설치-과정-중-발생한-오류">3. Node.js를 설치하고 <code class="language-plaintext highlighter-rouge">npm install</code>을 설치 과정 중 발생한 오류</h3>
<blockquote>
  <p>bash: npm: command not found</p>
</blockquote>

<p>위와 같은 오류가 발생했는데 이는 Node.js 설치폴더가 환경변수에 등록되어 있지 않기 때문에 발생한다. 
이는 https://wonisdaily.tistory.com/209 해당 블로그를 참고해서 해결했다.</p>

<hr />
<p>내가 한 방식이 정답이 아닐 수 있으나 해결했으니 마음이 후련하다~</p>]]></content><author><name>Ukja2</name><email>jaewooklee739@gmail.com</email></author><category term="Jekyll" /><category term="Jekyll theme" /><category term="Jekyll" /><summary type="html"><![CDATA[블로그를 개설 중 발생한 자잘한 오류 해결과 과정]]></summary></entry></feed>